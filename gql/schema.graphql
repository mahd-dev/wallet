"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `Budget`."""
  budgets(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Budget`."""
    orderBy: [BudgetsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BudgetCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BudgetFilter
  ): BudgetsConnection

  """Reads and enables pagination through a set of `Category`."""
  categories(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CategoryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CategoryFilter
  ): CategoriesConnection

  """Reads and enables pagination through a set of `OtpVerification`."""
  otpVerifications(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `OtpVerification`."""
    orderBy: [OtpVerificationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OtpVerificationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OtpVerificationFilter
  ): OtpVerificationsConnection

  """Reads and enables pagination through a set of `Report`."""
  reports(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Report`."""
    orderBy: [ReportsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReportCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ReportFilter
  ): ReportsConnection

  """Reads and enables pagination through a set of `Transaction`."""
  transactions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TransactionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TransactionFilter
  ): TransactionsConnection

  """Reads and enables pagination through a set of `User`."""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): UsersConnection

  """Reads and enables pagination through a set of `UserDevice`."""
  userDevices(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserDevice`."""
    orderBy: [UserDevicesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserDeviceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserDeviceFilter
  ): UserDevicesConnection
  budget(budgetId: String!): Budget
  category(id: String!): Category
  otpVerification(id: String!): OtpVerification
  report(reportId: String!): Report
  transaction(transactionId: String!): Transaction
  user(oidcId: String!): User
  userDevice(userId: String!, token: String!): UserDevice
  userDeviceByToken(token: String!): UserDevice

  """Reads a single `Budget` using its globally unique `ID`."""
  budgetByNodeId(
    """The globally unique `ID` to be used in selecting a single `Budget`."""
    nodeId: ID!
  ): Budget

  """Reads a single `Category` using its globally unique `ID`."""
  categoryByNodeId(
    """The globally unique `ID` to be used in selecting a single `Category`."""
    nodeId: ID!
  ): Category

  """Reads a single `OtpVerification` using its globally unique `ID`."""
  otpVerificationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `OtpVerification`.
    """
    nodeId: ID!
  ): OtpVerification

  """Reads a single `Report` using its globally unique `ID`."""
  reportByNodeId(
    """The globally unique `ID` to be used in selecting a single `Report`."""
    nodeId: ID!
  ): Report

  """Reads a single `Transaction` using its globally unique `ID`."""
  transactionByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Transaction`.
    """
    nodeId: ID!
  ): Transaction

  """Reads a single `User` using its globally unique `ID`."""
  userByNodeId(
    """The globally unique `ID` to be used in selecting a single `User`."""
    nodeId: ID!
  ): User

  """Reads a single `UserDevice` using its globally unique `ID`."""
  userDeviceByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `UserDevice`.
    """
    nodeId: ID!
  ): UserDevice
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `Budget` values."""
type BudgetsConnection {
  """A list of `Budget` objects."""
  nodes: [Budget!]!

  """
  A list of edges which contains the `Budget` and cursor to aid in pagination.
  """
  edges: [BudgetsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Budget` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: BudgetAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Budget` for these aggregates."""
    groupBy: [BudgetGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: BudgetHavingInput
  ): [BudgetAggregates!]
}

type Budget implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  budgetId: String!
  userId: String
  categoryId: String
  amount: Float
  month: Datetime
  alertThreshold: Int

  """Reads a single `User` that is related to this `Budget`."""
  user: User

  """Reads a single `Category` that is related to this `Budget`."""
  category: Category
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

type User implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  oidcId: String!
  firstName: String
  lastName: String
  gender: UserGender
  email: String
  tel: String
  picture: String
  password: String
  date: Datetime

  """Reads and enables pagination through a set of `UserDevice`."""
  userDevicesByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserDevice`."""
    orderBy: [UserDevicesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserDeviceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserDeviceFilter
  ): UserDevicesConnection!

  """Reads and enables pagination through a set of `Transaction`."""
  transactionsByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TransactionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TransactionFilter
  ): TransactionsConnection!

  """Reads and enables pagination through a set of `Budget`."""
  budgetsByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Budget`."""
    orderBy: [BudgetsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BudgetCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BudgetFilter
  ): BudgetsConnection!

  """Reads and enables pagination through a set of `Report`."""
  reportsByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Report`."""
    orderBy: [ReportsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReportCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ReportFilter
  ): ReportsConnection!

  """Reads and enables pagination through a set of `OtpVerification`."""
  otpVerificationsByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `OtpVerification`."""
    orderBy: [OtpVerificationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OtpVerificationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OtpVerificationFilter
  ): OtpVerificationsConnection!
}

enum UserGender {
  MALE
  FEMALE
}

"""A connection to a list of `UserDevice` values."""
type UserDevicesConnection {
  """A list of `UserDevice` objects."""
  nodes: [UserDevice!]!

  """
  A list of edges which contains the `UserDevice` and cursor to aid in pagination.
  """
  edges: [UserDevicesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `UserDevice` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: UserDeviceAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `UserDevice` for these aggregates."""
    groupBy: [UserDeviceGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: UserDeviceHavingInput
  ): [UserDeviceAggregates!]
}

type UserDevice implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  userId: String!
  token: String!
  ua: JSON

  """Reads a single `User` that is related to this `UserDevice`."""
  user: User
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""A `UserDevice` edge in the connection."""
type UserDevicesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserDevice` at the end of the edge."""
  node: UserDevice!
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

type UserDeviceAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: UserDeviceDistinctCountAggregates
}

type UserDeviceDistinctCountAggregates {
  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of token across the matching connection"""
  token: BigInt

  """Distinct count of ua across the matching connection"""
  ua: BigInt
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""Grouping methods for `UserDevice` for usage during aggregation."""
enum UserDeviceGroupBy {
  USER_ID
  UA
}

"""Conditions for `UserDevice` aggregates."""
input UserDeviceHavingInput {
  AND: [UserDeviceHavingInput!]
  OR: [UserDeviceHavingInput!]
}

"""Methods to use when ordering `UserDevice`."""
enum UserDevicesOrderBy {
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  TOKEN_ASC
  TOKEN_DESC
  UA_ASC
  UA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `UserDevice` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input UserDeviceCondition {
  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `token` field."""
  token: String

  """Checks for equality with the object’s `ua` field."""
  ua: JSON
}

"""
A filter to be used against `UserDevice` object types. All fields are combined with a logical ‘and.’
"""
input UserDeviceFilter {
  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `token` field."""
  token: StringFilter

  """Filter by the object’s `ua` field."""
  ua: JSONFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [UserDeviceFilter!]

  """Checks for any expressions in this list."""
  or: [UserDeviceFilter!]

  """Negates the expression."""
  not: UserDeviceFilter
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: String

  """Not equal to the specified value."""
  notEqualTo: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """Included in the specified list."""
  in: [String!]

  """Not included in the specified list."""
  notIn: [String!]

  """Less than the specified value."""
  lessThan: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String

  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]

  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]

  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String

  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String

  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String

  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String
}

"""
A filter to be used against JSON fields. All fields are combined with a logical ‘and.’
"""
input JSONFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: JSON

  """Not equal to the specified value."""
  notEqualTo: JSON

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: JSON

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: JSON

  """Included in the specified list."""
  in: [JSON!]

  """Not included in the specified list."""
  notIn: [JSON!]

  """Less than the specified value."""
  lessThan: JSON

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: JSON

  """Greater than the specified value."""
  greaterThan: JSON

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: JSON

  """Contains the specified JSON."""
  contains: JSON

  """Contains the specified key."""
  containsKey: String

  """Contains all of the specified keys."""
  containsAllKeys: [String!]

  """Contains any of the specified keys."""
  containsAnyKeys: [String!]

  """Contained by the specified JSON."""
  containedBy: JSON
}

"""
A filter to be used against `User` object types. All fields are combined with a logical ‘and.’
"""
input UserFilter {
  """Filter by the object’s `oidcId` field."""
  oidcId: StringFilter

  """Filter by the object’s `firstName` field."""
  firstName: StringFilter

  """Filter by the object’s `lastName` field."""
  lastName: StringFilter

  """Filter by the object’s `gender` field."""
  gender: UserGenderFilter

  """Filter by the object’s `email` field."""
  email: StringFilter

  """Filter by the object’s `tel` field."""
  tel: StringFilter

  """Filter by the object’s `picture` field."""
  picture: StringFilter

  """Filter by the object’s `password` field."""
  password: StringFilter

  """Filter by the object’s `date` field."""
  date: DatetimeFilter

  """Filter by the object’s `userDevicesByUserId` relation."""
  userDevicesByUserId: UserToManyUserDeviceFilter

  """Some related `userDevicesByUserId` exist."""
  userDevicesByUserIdExist: Boolean

  """Filter by the object’s `transactionsByUserId` relation."""
  transactionsByUserId: UserToManyTransactionFilter

  """Some related `transactionsByUserId` exist."""
  transactionsByUserIdExist: Boolean

  """Filter by the object’s `budgetsByUserId` relation."""
  budgetsByUserId: UserToManyBudgetFilter

  """Some related `budgetsByUserId` exist."""
  budgetsByUserIdExist: Boolean

  """Filter by the object’s `reportsByUserId` relation."""
  reportsByUserId: UserToManyReportFilter

  """Some related `reportsByUserId` exist."""
  reportsByUserIdExist: Boolean

  """Filter by the object’s `otpVerificationsByUserId` relation."""
  otpVerificationsByUserId: UserToManyOtpVerificationFilter

  """Some related `otpVerificationsByUserId` exist."""
  otpVerificationsByUserIdExist: Boolean

  """Checks for all expressions in this list."""
  and: [UserFilter!]

  """Checks for any expressions in this list."""
  or: [UserFilter!]

  """Negates the expression."""
  not: UserFilter
}

"""
A filter to be used against UserGender fields. All fields are combined with a logical ‘and.’
"""
input UserGenderFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: UserGender

  """Not equal to the specified value."""
  notEqualTo: UserGender

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: UserGender

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: UserGender

  """Included in the specified list."""
  in: [UserGender!]

  """Not included in the specified list."""
  notIn: [UserGender!]

  """Less than the specified value."""
  lessThan: UserGender

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: UserGender

  """Greater than the specified value."""
  greaterThan: UserGender

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: UserGender
}

"""
A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’
"""
input DatetimeFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Datetime

  """Not equal to the specified value."""
  notEqualTo: Datetime

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Datetime

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Datetime

  """Included in the specified list."""
  in: [Datetime!]

  """Not included in the specified list."""
  notIn: [Datetime!]

  """Less than the specified value."""
  lessThan: Datetime

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Datetime

  """Greater than the specified value."""
  greaterThan: Datetime

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Datetime
}

"""
A filter to be used against many `UserDevice` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyUserDeviceFilter {
  """
  Every related `UserDevice` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: UserDeviceFilter

  """
  Some related `UserDevice` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: UserDeviceFilter

  """
  No related `UserDevice` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: UserDeviceFilter

  """Aggregates across related `UserDevice` match the filter criteria."""
  aggregates: UserDeviceAggregatesFilter
}

"""A filter to be used against aggregates of `UserDevice` object types."""
input UserDeviceAggregatesFilter {
  """
  A filter that must pass for the relevant `UserDevice` object to be included within the aggregate.
  """
  filter: UserDeviceFilter

  """Distinct count aggregate over matching `UserDevice` objects."""
  distinctCount: UserDeviceDistinctCountAggregateFilter
}

input UserDeviceDistinctCountAggregateFilter {
  userId: BigIntFilter
  token: BigIntFilter
  ua: BigIntFilter
}

"""
A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’
"""
input BigIntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigInt

  """Not equal to the specified value."""
  notEqualTo: BigInt

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigInt

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigInt

  """Included in the specified list."""
  in: [BigInt!]

  """Not included in the specified list."""
  notIn: [BigInt!]

  """Less than the specified value."""
  lessThan: BigInt

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigInt

  """Greater than the specified value."""
  greaterThan: BigInt

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigInt
}

"""
A filter to be used against many `Transaction` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyTransactionFilter {
  """
  Every related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TransactionFilter

  """
  Some related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TransactionFilter

  """
  No related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TransactionFilter

  """Aggregates across related `Transaction` match the filter criteria."""
  aggregates: TransactionAggregatesFilter
}

"""
A filter to be used against `Transaction` object types. All fields are combined with a logical ‘and.’
"""
input TransactionFilter {
  """Filter by the object’s `transactionId` field."""
  transactionId: StringFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `categoryId` field."""
  categoryId: StringFilter

  """Filter by the object’s `amount` field."""
  amount: FloatFilter

  """Filter by the object’s `date` field."""
  date: DatetimeFilter

  """Filter by the object’s `description` field."""
  description: StringFilter

  """Filter by the object’s `type` field."""
  type: TypetransactionFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """A related `user` exists."""
  userExists: Boolean

  """Filter by the object’s `category` relation."""
  category: CategoryFilter

  """A related `category` exists."""
  categoryExists: Boolean

  """Checks for all expressions in this list."""
  and: [TransactionFilter!]

  """Checks for any expressions in this list."""
  or: [TransactionFilter!]

  """Negates the expression."""
  not: TransactionFilter
}

"""
A filter to be used against Float fields. All fields are combined with a logical ‘and.’
"""
input FloatFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Float

  """Not equal to the specified value."""
  notEqualTo: Float

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Float

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Float

  """Included in the specified list."""
  in: [Float!]

  """Not included in the specified list."""
  notIn: [Float!]

  """Less than the specified value."""
  lessThan: Float

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Float

  """Greater than the specified value."""
  greaterThan: Float

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Float
}

"""
A filter to be used against Typetransaction fields. All fields are combined with a logical ‘and.’
"""
input TypetransactionFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Typetransaction

  """Not equal to the specified value."""
  notEqualTo: Typetransaction

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Typetransaction

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Typetransaction

  """Included in the specified list."""
  in: [Typetransaction!]

  """Not included in the specified list."""
  notIn: [Typetransaction!]

  """Less than the specified value."""
  lessThan: Typetransaction

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Typetransaction

  """Greater than the specified value."""
  greaterThan: Typetransaction

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Typetransaction
}

enum Typetransaction {
  INCOME
  EXPENSE
}

"""
A filter to be used against `Category` object types. All fields are combined with a logical ‘and.’
"""
input CategoryFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `transactionsByCategoryId` relation."""
  transactionsByCategoryId: CategoryToManyTransactionFilter

  """Some related `transactionsByCategoryId` exist."""
  transactionsByCategoryIdExist: Boolean

  """Filter by the object’s `budgetsByCategoryId` relation."""
  budgetsByCategoryId: CategoryToManyBudgetFilter

  """Some related `budgetsByCategoryId` exist."""
  budgetsByCategoryIdExist: Boolean

  """Checks for all expressions in this list."""
  and: [CategoryFilter!]

  """Checks for any expressions in this list."""
  or: [CategoryFilter!]

  """Negates the expression."""
  not: CategoryFilter
}

"""
A filter to be used against many `Transaction` object types. All fields are combined with a logical ‘and.’
"""
input CategoryToManyTransactionFilter {
  """
  Every related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TransactionFilter

  """
  Some related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TransactionFilter

  """
  No related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TransactionFilter

  """Aggregates across related `Transaction` match the filter criteria."""
  aggregates: TransactionAggregatesFilter
}

"""A filter to be used against aggregates of `Transaction` object types."""
input TransactionAggregatesFilter {
  """
  A filter that must pass for the relevant `Transaction` object to be included within the aggregate.
  """
  filter: TransactionFilter

  """Sum aggregate over matching `Transaction` objects."""
  sum: TransactionSumAggregateFilter

  """Distinct count aggregate over matching `Transaction` objects."""
  distinctCount: TransactionDistinctCountAggregateFilter

  """Minimum aggregate over matching `Transaction` objects."""
  min: TransactionMinAggregateFilter

  """Maximum aggregate over matching `Transaction` objects."""
  max: TransactionMaxAggregateFilter

  """Mean average aggregate over matching `Transaction` objects."""
  average: TransactionAverageAggregateFilter

  """
  Sample standard deviation aggregate over matching `Transaction` objects.
  """
  stddevSample: TransactionStddevSampleAggregateFilter

  """
  Population standard deviation aggregate over matching `Transaction` objects.
  """
  stddevPopulation: TransactionStddevPopulationAggregateFilter

  """Sample variance aggregate over matching `Transaction` objects."""
  varianceSample: TransactionVarianceSampleAggregateFilter

  """Population variance aggregate over matching `Transaction` objects."""
  variancePopulation: TransactionVariancePopulationAggregateFilter
}

input TransactionSumAggregateFilter {
  amount: FloatFilter
}

input TransactionDistinctCountAggregateFilter {
  transactionId: BigIntFilter
  userId: BigIntFilter
  categoryId: BigIntFilter
  amount: BigIntFilter
  date: BigIntFilter
  description: BigIntFilter
  type: BigIntFilter
}

input TransactionMinAggregateFilter {
  amount: FloatFilter
}

input TransactionMaxAggregateFilter {
  amount: FloatFilter
}

input TransactionAverageAggregateFilter {
  amount: FloatFilter
}

input TransactionStddevSampleAggregateFilter {
  amount: FloatFilter
}

input TransactionStddevPopulationAggregateFilter {
  amount: FloatFilter
}

input TransactionVarianceSampleAggregateFilter {
  amount: FloatFilter
}

input TransactionVariancePopulationAggregateFilter {
  amount: FloatFilter
}

"""
A filter to be used against many `Budget` object types. All fields are combined with a logical ‘and.’
"""
input CategoryToManyBudgetFilter {
  """
  Every related `Budget` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: BudgetFilter

  """
  Some related `Budget` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: BudgetFilter

  """
  No related `Budget` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: BudgetFilter

  """Aggregates across related `Budget` match the filter criteria."""
  aggregates: BudgetAggregatesFilter
}

"""
A filter to be used against `Budget` object types. All fields are combined with a logical ‘and.’
"""
input BudgetFilter {
  """Filter by the object’s `budgetId` field."""
  budgetId: StringFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `categoryId` field."""
  categoryId: StringFilter

  """Filter by the object’s `amount` field."""
  amount: FloatFilter

  """Filter by the object’s `month` field."""
  month: DatetimeFilter

  """Filter by the object’s `alertThreshold` field."""
  alertThreshold: IntFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """A related `user` exists."""
  userExists: Boolean

  """Filter by the object’s `category` relation."""
  category: CategoryFilter

  """A related `category` exists."""
  categoryExists: Boolean

  """Checks for all expressions in this list."""
  and: [BudgetFilter!]

  """Checks for any expressions in this list."""
  or: [BudgetFilter!]

  """Negates the expression."""
  not: BudgetFilter
}

"""
A filter to be used against Int fields. All fields are combined with a logical ‘and.’
"""
input IntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Int

  """Not equal to the specified value."""
  notEqualTo: Int

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Int

  """Included in the specified list."""
  in: [Int!]

  """Not included in the specified list."""
  notIn: [Int!]

  """Less than the specified value."""
  lessThan: Int

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Int

  """Greater than the specified value."""
  greaterThan: Int

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Int
}

"""A filter to be used against aggregates of `Budget` object types."""
input BudgetAggregatesFilter {
  """
  A filter that must pass for the relevant `Budget` object to be included within the aggregate.
  """
  filter: BudgetFilter

  """Sum aggregate over matching `Budget` objects."""
  sum: BudgetSumAggregateFilter

  """Distinct count aggregate over matching `Budget` objects."""
  distinctCount: BudgetDistinctCountAggregateFilter

  """Minimum aggregate over matching `Budget` objects."""
  min: BudgetMinAggregateFilter

  """Maximum aggregate over matching `Budget` objects."""
  max: BudgetMaxAggregateFilter

  """Mean average aggregate over matching `Budget` objects."""
  average: BudgetAverageAggregateFilter

  """Sample standard deviation aggregate over matching `Budget` objects."""
  stddevSample: BudgetStddevSampleAggregateFilter

  """
  Population standard deviation aggregate over matching `Budget` objects.
  """
  stddevPopulation: BudgetStddevPopulationAggregateFilter

  """Sample variance aggregate over matching `Budget` objects."""
  varianceSample: BudgetVarianceSampleAggregateFilter

  """Population variance aggregate over matching `Budget` objects."""
  variancePopulation: BudgetVariancePopulationAggregateFilter
}

input BudgetSumAggregateFilter {
  amount: FloatFilter
  alertThreshold: BigIntFilter
}

input BudgetDistinctCountAggregateFilter {
  budgetId: BigIntFilter
  userId: BigIntFilter
  categoryId: BigIntFilter
  amount: BigIntFilter
  month: BigIntFilter
  alertThreshold: BigIntFilter
}

input BudgetMinAggregateFilter {
  amount: FloatFilter
  alertThreshold: IntFilter
}

input BudgetMaxAggregateFilter {
  amount: FloatFilter
  alertThreshold: IntFilter
}

input BudgetAverageAggregateFilter {
  amount: FloatFilter
  alertThreshold: BigFloatFilter
}

"""
A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’
"""
input BigFloatFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigFloat

  """Not equal to the specified value."""
  notEqualTo: BigFloat

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigFloat

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigFloat

  """Included in the specified list."""
  in: [BigFloat!]

  """Not included in the specified list."""
  notIn: [BigFloat!]

  """Less than the specified value."""
  lessThan: BigFloat

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigFloat

  """Greater than the specified value."""
  greaterThan: BigFloat

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigFloat
}

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

input BudgetStddevSampleAggregateFilter {
  amount: FloatFilter
  alertThreshold: BigFloatFilter
}

input BudgetStddevPopulationAggregateFilter {
  amount: FloatFilter
  alertThreshold: BigFloatFilter
}

input BudgetVarianceSampleAggregateFilter {
  amount: FloatFilter
  alertThreshold: BigFloatFilter
}

input BudgetVariancePopulationAggregateFilter {
  amount: FloatFilter
  alertThreshold: BigFloatFilter
}

"""
A filter to be used against many `Budget` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyBudgetFilter {
  """
  Every related `Budget` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: BudgetFilter

  """
  Some related `Budget` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: BudgetFilter

  """
  No related `Budget` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: BudgetFilter

  """Aggregates across related `Budget` match the filter criteria."""
  aggregates: BudgetAggregatesFilter
}

"""
A filter to be used against many `Report` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyReportFilter {
  """
  Every related `Report` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ReportFilter

  """
  Some related `Report` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ReportFilter

  """
  No related `Report` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ReportFilter

  """Aggregates across related `Report` match the filter criteria."""
  aggregates: ReportAggregatesFilter
}

"""
A filter to be used against `Report` object types. All fields are combined with a logical ‘and.’
"""
input ReportFilter {
  """Filter by the object’s `reportId` field."""
  reportId: StringFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: StringFilter

  """Filter by the object’s `filePath` field."""
  filePath: StringFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """A related `user` exists."""
  userExists: Boolean

  """Checks for all expressions in this list."""
  and: [ReportFilter!]

  """Checks for any expressions in this list."""
  or: [ReportFilter!]

  """Negates the expression."""
  not: ReportFilter
}

"""A filter to be used against aggregates of `Report` object types."""
input ReportAggregatesFilter {
  """
  A filter that must pass for the relevant `Report` object to be included within the aggregate.
  """
  filter: ReportFilter

  """Distinct count aggregate over matching `Report` objects."""
  distinctCount: ReportDistinctCountAggregateFilter
}

input ReportDistinctCountAggregateFilter {
  reportId: BigIntFilter
  userId: BigIntFilter
  createdAt: BigIntFilter
  filePath: BigIntFilter
}

"""
A filter to be used against many `OtpVerification` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyOtpVerificationFilter {
  """
  Every related `OtpVerification` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: OtpVerificationFilter

  """
  Some related `OtpVerification` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: OtpVerificationFilter

  """
  No related `OtpVerification` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: OtpVerificationFilter

  """Aggregates across related `OtpVerification` match the filter criteria."""
  aggregates: OtpVerificationAggregatesFilter
}

"""
A filter to be used against `OtpVerification` object types. All fields are combined with a logical ‘and.’
"""
input OtpVerificationFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `otp` field."""
  otp: StringFilter

  """Filter by the object’s `expiresAt` field."""
  expiresAt: DatetimeFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `email` field."""
  email: StringFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [OtpVerificationFilter!]

  """Checks for any expressions in this list."""
  or: [OtpVerificationFilter!]

  """Negates the expression."""
  not: OtpVerificationFilter
}

"""
A filter to be used against aggregates of `OtpVerification` object types.
"""
input OtpVerificationAggregatesFilter {
  """
  A filter that must pass for the relevant `OtpVerification` object to be included within the aggregate.
  """
  filter: OtpVerificationFilter

  """Distinct count aggregate over matching `OtpVerification` objects."""
  distinctCount: OtpVerificationDistinctCountAggregateFilter
}

input OtpVerificationDistinctCountAggregateFilter {
  id: BigIntFilter
  userId: BigIntFilter
  otp: BigIntFilter
  expiresAt: BigIntFilter
  createdAt: BigIntFilter
  email: BigIntFilter
}

"""A connection to a list of `Transaction` values."""
type TransactionsConnection {
  """A list of `Transaction` objects."""
  nodes: [Transaction!]!

  """
  A list of edges which contains the `Transaction` and cursor to aid in pagination.
  """
  edges: [TransactionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Transaction` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: TransactionAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Transaction` for these aggregates."""
    groupBy: [TransactionGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: TransactionHavingInput
  ): [TransactionAggregates!]
}

type Transaction implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  transactionId: String!
  userId: String
  categoryId: String
  amount: Float!
  date: Datetime
  description: String
  type: Typetransaction!

  """Reads a single `User` that is related to this `Transaction`."""
  user: User

  """Reads a single `Category` that is related to this `Transaction`."""
  category: Category
}

type Category implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  name: String!

  """Reads and enables pagination through a set of `Transaction`."""
  transactionsByCategoryId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TransactionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TransactionFilter
  ): TransactionsConnection!

  """Reads and enables pagination through a set of `Budget`."""
  budgetsByCategoryId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Budget`."""
    orderBy: [BudgetsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BudgetCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BudgetFilter
  ): BudgetsConnection!
}

"""Methods to use when ordering `Transaction`."""
enum TransactionsOrderBy {
  NATURAL
  TRANSACTION_ID_ASC
  TRANSACTION_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CATEGORY_ID_ASC
  CATEGORY_ID_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  DATE_ASC
  DATE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  TYPE_ASC
  TYPE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Transaction` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TransactionCondition {
  """Checks for equality with the object’s `transactionId` field."""
  transactionId: String

  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `categoryId` field."""
  categoryId: String

  """Checks for equality with the object’s `amount` field."""
  amount: Float

  """Checks for equality with the object’s `date` field."""
  date: Datetime

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `type` field."""
  type: Typetransaction
}

"""Methods to use when ordering `Budget`."""
enum BudgetsOrderBy {
  NATURAL
  BUDGET_ID_ASC
  BUDGET_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CATEGORY_ID_ASC
  CATEGORY_ID_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  MONTH_ASC
  MONTH_DESC
  ALERT_THRESHOLD_ASC
  ALERT_THRESHOLD_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Budget` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input BudgetCondition {
  """Checks for equality with the object’s `budgetId` field."""
  budgetId: String

  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `categoryId` field."""
  categoryId: String

  """Checks for equality with the object’s `amount` field."""
  amount: Float

  """Checks for equality with the object’s `month` field."""
  month: Datetime

  """Checks for equality with the object’s `alertThreshold` field."""
  alertThreshold: Int
}

"""A `Transaction` edge in the connection."""
type TransactionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Transaction` at the end of the edge."""
  node: Transaction!
}

type TransactionAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: TransactionSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: TransactionDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: TransactionMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: TransactionMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: TransactionAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: TransactionStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: TransactionStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: TransactionVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: TransactionVariancePopulationAggregates
}

type TransactionSumAggregates {
  """Sum of amount across the matching connection"""
  amount: Float!
}

type TransactionDistinctCountAggregates {
  """Distinct count of transactionId across the matching connection"""
  transactionId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of categoryId across the matching connection"""
  categoryId: BigInt

  """Distinct count of amount across the matching connection"""
  amount: BigInt

  """Distinct count of date across the matching connection"""
  date: BigInt

  """Distinct count of description across the matching connection"""
  description: BigInt

  """Distinct count of type across the matching connection"""
  type: BigInt
}

type TransactionMinAggregates {
  """Minimum of amount across the matching connection"""
  amount: Float
}

type TransactionMaxAggregates {
  """Maximum of amount across the matching connection"""
  amount: Float
}

type TransactionAverageAggregates {
  """Mean average of amount across the matching connection"""
  amount: Float
}

type TransactionStddevSampleAggregates {
  """Sample standard deviation of amount across the matching connection"""
  amount: Float
}

type TransactionStddevPopulationAggregates {
  """Population standard deviation of amount across the matching connection"""
  amount: Float
}

type TransactionVarianceSampleAggregates {
  """Sample variance of amount across the matching connection"""
  amount: Float
}

type TransactionVariancePopulationAggregates {
  """Population variance of amount across the matching connection"""
  amount: Float
}

"""Grouping methods for `Transaction` for usage during aggregation."""
enum TransactionGroupBy {
  USER_ID
  CATEGORY_ID
  AMOUNT
  DATE
  DATE_TRUNCATED_TO_HOUR
  DATE_TRUNCATED_TO_DAY
  DESCRIPTION
  TYPE
}

"""Conditions for `Transaction` aggregates."""
input TransactionHavingInput {
  AND: [TransactionHavingInput!]
  OR: [TransactionHavingInput!]
  sum: TransactionHavingSumInput
  distinctCount: TransactionHavingDistinctCountInput
  min: TransactionHavingMinInput
  max: TransactionHavingMaxInput
  average: TransactionHavingAverageInput
  stddevSample: TransactionHavingStddevSampleInput
  stddevPopulation: TransactionHavingStddevPopulationInput
  varianceSample: TransactionHavingVarianceSampleInput
  variancePopulation: TransactionHavingVariancePopulationInput
}

input TransactionHavingSumInput {
  amount: HavingFloatFilter
  date: HavingDatetimeFilter
}

input HavingFloatFilter {
  equalTo: Float
  notEqualTo: Float
  greaterThan: Float
  greaterThanOrEqualTo: Float
  lessThan: Float
  lessThanOrEqualTo: Float
}

input HavingDatetimeFilter {
  equalTo: Datetime
  notEqualTo: Datetime
  greaterThan: Datetime
  greaterThanOrEqualTo: Datetime
  lessThan: Datetime
  lessThanOrEqualTo: Datetime
}

input TransactionHavingDistinctCountInput {
  amount: HavingFloatFilter
  date: HavingDatetimeFilter
}

input TransactionHavingMinInput {
  amount: HavingFloatFilter
  date: HavingDatetimeFilter
}

input TransactionHavingMaxInput {
  amount: HavingFloatFilter
  date: HavingDatetimeFilter
}

input TransactionHavingAverageInput {
  amount: HavingFloatFilter
  date: HavingDatetimeFilter
}

input TransactionHavingStddevSampleInput {
  amount: HavingFloatFilter
  date: HavingDatetimeFilter
}

input TransactionHavingStddevPopulationInput {
  amount: HavingFloatFilter
  date: HavingDatetimeFilter
}

input TransactionHavingVarianceSampleInput {
  amount: HavingFloatFilter
  date: HavingDatetimeFilter
}

input TransactionHavingVariancePopulationInput {
  amount: HavingFloatFilter
  date: HavingDatetimeFilter
}

"""A connection to a list of `Report` values."""
type ReportsConnection {
  """A list of `Report` objects."""
  nodes: [Report!]!

  """
  A list of edges which contains the `Report` and cursor to aid in pagination.
  """
  edges: [ReportsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Report` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ReportAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Report` for these aggregates."""
    groupBy: [ReportGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ReportHavingInput
  ): [ReportAggregates!]
}

type Report implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  reportId: String!
  userId: String
  createdAt: String
  filePath: String

  """Reads a single `User` that is related to this `Report`."""
  user: User
}

"""A `Report` edge in the connection."""
type ReportsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Report` at the end of the edge."""
  node: Report!
}

type ReportAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ReportDistinctCountAggregates
}

type ReportDistinctCountAggregates {
  """Distinct count of reportId across the matching connection"""
  reportId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of filePath across the matching connection"""
  filePath: BigInt
}

"""Grouping methods for `Report` for usage during aggregation."""
enum ReportGroupBy {
  USER_ID
  CREATED_AT
  FILE_PATH
}

"""Conditions for `Report` aggregates."""
input ReportHavingInput {
  AND: [ReportHavingInput!]
  OR: [ReportHavingInput!]
}

"""Methods to use when ordering `Report`."""
enum ReportsOrderBy {
  NATURAL
  REPORT_ID_ASC
  REPORT_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  FILE_PATH_ASC
  FILE_PATH_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Report` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ReportCondition {
  """Checks for equality with the object’s `reportId` field."""
  reportId: String

  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: String

  """Checks for equality with the object’s `filePath` field."""
  filePath: String
}

"""A connection to a list of `OtpVerification` values."""
type OtpVerificationsConnection {
  """A list of `OtpVerification` objects."""
  nodes: [OtpVerification!]!

  """
  A list of edges which contains the `OtpVerification` and cursor to aid in pagination.
  """
  edges: [OtpVerificationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `OtpVerification` you could get from the connection.
  """
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: OtpVerificationAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `OtpVerification` for these aggregates.
    """
    groupBy: [OtpVerificationGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: OtpVerificationHavingInput
  ): [OtpVerificationAggregates!]
}

type OtpVerification implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  userId: String!
  otp: String!
  expiresAt: Datetime!
  createdAt: Datetime!
  email: String

  """Reads a single `User` that is related to this `OtpVerification`."""
  user: User
}

"""A `OtpVerification` edge in the connection."""
type OtpVerificationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `OtpVerification` at the end of the edge."""
  node: OtpVerification!
}

type OtpVerificationAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: OtpVerificationDistinctCountAggregates
}

type OtpVerificationDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of otp across the matching connection"""
  otp: BigInt

  """Distinct count of expiresAt across the matching connection"""
  expiresAt: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of email across the matching connection"""
  email: BigInt
}

"""Grouping methods for `OtpVerification` for usage during aggregation."""
enum OtpVerificationGroupBy {
  USER_ID
  OTP
  EXPIRES_AT
  EXPIRES_AT_TRUNCATED_TO_HOUR
  EXPIRES_AT_TRUNCATED_TO_DAY
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  EMAIL
}

"""Conditions for `OtpVerification` aggregates."""
input OtpVerificationHavingInput {
  AND: [OtpVerificationHavingInput!]
  OR: [OtpVerificationHavingInput!]
  sum: OtpVerificationHavingSumInput
  distinctCount: OtpVerificationHavingDistinctCountInput
  min: OtpVerificationHavingMinInput
  max: OtpVerificationHavingMaxInput
  average: OtpVerificationHavingAverageInput
  stddevSample: OtpVerificationHavingStddevSampleInput
  stddevPopulation: OtpVerificationHavingStddevPopulationInput
  varianceSample: OtpVerificationHavingVarianceSampleInput
  variancePopulation: OtpVerificationHavingVariancePopulationInput
}

input OtpVerificationHavingSumInput {
  expiresAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
}

input OtpVerificationHavingDistinctCountInput {
  expiresAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
}

input OtpVerificationHavingMinInput {
  expiresAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
}

input OtpVerificationHavingMaxInput {
  expiresAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
}

input OtpVerificationHavingAverageInput {
  expiresAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
}

input OtpVerificationHavingStddevSampleInput {
  expiresAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
}

input OtpVerificationHavingStddevPopulationInput {
  expiresAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
}

input OtpVerificationHavingVarianceSampleInput {
  expiresAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
}

input OtpVerificationHavingVariancePopulationInput {
  expiresAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
}

"""Methods to use when ordering `OtpVerification`."""
enum OtpVerificationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  OTP_ASC
  OTP_DESC
  EXPIRES_AT_ASC
  EXPIRES_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  EMAIL_ASC
  EMAIL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `OtpVerification` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input OtpVerificationCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `otp` field."""
  otp: String

  """Checks for equality with the object’s `expiresAt` field."""
  expiresAt: Datetime

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `email` field."""
  email: String
}

"""A `Budget` edge in the connection."""
type BudgetsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Budget` at the end of the edge."""
  node: Budget!
}

type BudgetAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: BudgetSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: BudgetDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: BudgetMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: BudgetMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: BudgetAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: BudgetStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: BudgetStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: BudgetVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: BudgetVariancePopulationAggregates
}

type BudgetSumAggregates {
  """Sum of amount across the matching connection"""
  amount: Float!

  """Sum of alertThreshold across the matching connection"""
  alertThreshold: BigInt!
}

type BudgetDistinctCountAggregates {
  """Distinct count of budgetId across the matching connection"""
  budgetId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of categoryId across the matching connection"""
  categoryId: BigInt

  """Distinct count of amount across the matching connection"""
  amount: BigInt

  """Distinct count of month across the matching connection"""
  month: BigInt

  """Distinct count of alertThreshold across the matching connection"""
  alertThreshold: BigInt
}

type BudgetMinAggregates {
  """Minimum of amount across the matching connection"""
  amount: Float

  """Minimum of alertThreshold across the matching connection"""
  alertThreshold: Int
}

type BudgetMaxAggregates {
  """Maximum of amount across the matching connection"""
  amount: Float

  """Maximum of alertThreshold across the matching connection"""
  alertThreshold: Int
}

type BudgetAverageAggregates {
  """Mean average of amount across the matching connection"""
  amount: Float

  """Mean average of alertThreshold across the matching connection"""
  alertThreshold: BigFloat
}

type BudgetStddevSampleAggregates {
  """Sample standard deviation of amount across the matching connection"""
  amount: Float

  """
  Sample standard deviation of alertThreshold across the matching connection
  """
  alertThreshold: BigFloat
}

type BudgetStddevPopulationAggregates {
  """Population standard deviation of amount across the matching connection"""
  amount: Float

  """
  Population standard deviation of alertThreshold across the matching connection
  """
  alertThreshold: BigFloat
}

type BudgetVarianceSampleAggregates {
  """Sample variance of amount across the matching connection"""
  amount: Float

  """Sample variance of alertThreshold across the matching connection"""
  alertThreshold: BigFloat
}

type BudgetVariancePopulationAggregates {
  """Population variance of amount across the matching connection"""
  amount: Float

  """Population variance of alertThreshold across the matching connection"""
  alertThreshold: BigFloat
}

"""Grouping methods for `Budget` for usage during aggregation."""
enum BudgetGroupBy {
  USER_ID
  CATEGORY_ID
  AMOUNT
  MONTH
  MONTH_TRUNCATED_TO_HOUR
  MONTH_TRUNCATED_TO_DAY
  ALERT_THRESHOLD
}

"""Conditions for `Budget` aggregates."""
input BudgetHavingInput {
  AND: [BudgetHavingInput!]
  OR: [BudgetHavingInput!]
  sum: BudgetHavingSumInput
  distinctCount: BudgetHavingDistinctCountInput
  min: BudgetHavingMinInput
  max: BudgetHavingMaxInput
  average: BudgetHavingAverageInput
  stddevSample: BudgetHavingStddevSampleInput
  stddevPopulation: BudgetHavingStddevPopulationInput
  varianceSample: BudgetHavingVarianceSampleInput
  variancePopulation: BudgetHavingVariancePopulationInput
}

input BudgetHavingSumInput {
  amount: HavingFloatFilter
  month: HavingDatetimeFilter
  alertThreshold: HavingIntFilter
}

input HavingIntFilter {
  equalTo: Int
  notEqualTo: Int
  greaterThan: Int
  greaterThanOrEqualTo: Int
  lessThan: Int
  lessThanOrEqualTo: Int
}

input BudgetHavingDistinctCountInput {
  amount: HavingFloatFilter
  month: HavingDatetimeFilter
  alertThreshold: HavingIntFilter
}

input BudgetHavingMinInput {
  amount: HavingFloatFilter
  month: HavingDatetimeFilter
  alertThreshold: HavingIntFilter
}

input BudgetHavingMaxInput {
  amount: HavingFloatFilter
  month: HavingDatetimeFilter
  alertThreshold: HavingIntFilter
}

input BudgetHavingAverageInput {
  amount: HavingFloatFilter
  month: HavingDatetimeFilter
  alertThreshold: HavingIntFilter
}

input BudgetHavingStddevSampleInput {
  amount: HavingFloatFilter
  month: HavingDatetimeFilter
  alertThreshold: HavingIntFilter
}

input BudgetHavingStddevPopulationInput {
  amount: HavingFloatFilter
  month: HavingDatetimeFilter
  alertThreshold: HavingIntFilter
}

input BudgetHavingVarianceSampleInput {
  amount: HavingFloatFilter
  month: HavingDatetimeFilter
  alertThreshold: HavingIntFilter
}

input BudgetHavingVariancePopulationInput {
  amount: HavingFloatFilter
  month: HavingDatetimeFilter
  alertThreshold: HavingIntFilter
}

"""A connection to a list of `Category` values."""
type CategoriesConnection {
  """A list of `Category` objects."""
  nodes: [Category!]!

  """
  A list of edges which contains the `Category` and cursor to aid in pagination.
  """
  edges: [CategoriesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Category` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: CategoryAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Category` for these aggregates."""
    groupBy: [CategoryGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: CategoryHavingInput
  ): [CategoryAggregates!]
}

"""A `Category` edge in the connection."""
type CategoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Category` at the end of the edge."""
  node: Category!
}

type CategoryAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: CategoryDistinctCountAggregates
}

type CategoryDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt
}

"""Grouping methods for `Category` for usage during aggregation."""
enum CategoryGroupBy {
  NAME
}

"""Conditions for `Category` aggregates."""
input CategoryHavingInput {
  AND: [CategoryHavingInput!]
  OR: [CategoryHavingInput!]
}

"""Methods to use when ordering `Category`."""
enum CategoriesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TRANSACTIONS_BY_CATEGORY_ID_COUNT_ASC
  TRANSACTIONS_BY_CATEGORY_ID_COUNT_DESC
  TRANSACTIONS_BY_CATEGORY_ID_SUM_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_SUM_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_SUM_USER_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_SUM_USER_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_SUM_CATEGORY_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_SUM_CATEGORY_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_SUM_AMOUNT_ASC
  TRANSACTIONS_BY_CATEGORY_ID_SUM_AMOUNT_DESC
  TRANSACTIONS_BY_CATEGORY_ID_SUM_DATE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_SUM_DATE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_SUM_DESCRIPTION_ASC
  TRANSACTIONS_BY_CATEGORY_ID_SUM_DESCRIPTION_DESC
  TRANSACTIONS_BY_CATEGORY_ID_SUM_TYPE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_SUM_TYPE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_DISTINCT_COUNT_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_DISTINCT_COUNT_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_DISTINCT_COUNT_USER_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_DISTINCT_COUNT_USER_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_DISTINCT_COUNT_CATEGORY_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_DISTINCT_COUNT_CATEGORY_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_DISTINCT_COUNT_AMOUNT_ASC
  TRANSACTIONS_BY_CATEGORY_ID_DISTINCT_COUNT_AMOUNT_DESC
  TRANSACTIONS_BY_CATEGORY_ID_DISTINCT_COUNT_DATE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_DISTINCT_COUNT_DATE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_DISTINCT_COUNT_DESCRIPTION_ASC
  TRANSACTIONS_BY_CATEGORY_ID_DISTINCT_COUNT_DESCRIPTION_DESC
  TRANSACTIONS_BY_CATEGORY_ID_DISTINCT_COUNT_TYPE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_DISTINCT_COUNT_TYPE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_MIN_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_MIN_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_MIN_USER_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_MIN_USER_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_MIN_CATEGORY_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_MIN_CATEGORY_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_MIN_AMOUNT_ASC
  TRANSACTIONS_BY_CATEGORY_ID_MIN_AMOUNT_DESC
  TRANSACTIONS_BY_CATEGORY_ID_MIN_DATE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_MIN_DATE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_MIN_DESCRIPTION_ASC
  TRANSACTIONS_BY_CATEGORY_ID_MIN_DESCRIPTION_DESC
  TRANSACTIONS_BY_CATEGORY_ID_MIN_TYPE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_MIN_TYPE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_MAX_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_MAX_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_MAX_USER_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_MAX_USER_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_MAX_CATEGORY_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_MAX_CATEGORY_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_MAX_AMOUNT_ASC
  TRANSACTIONS_BY_CATEGORY_ID_MAX_AMOUNT_DESC
  TRANSACTIONS_BY_CATEGORY_ID_MAX_DATE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_MAX_DATE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_MAX_DESCRIPTION_ASC
  TRANSACTIONS_BY_CATEGORY_ID_MAX_DESCRIPTION_DESC
  TRANSACTIONS_BY_CATEGORY_ID_MAX_TYPE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_MAX_TYPE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_AVERAGE_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_AVERAGE_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_AVERAGE_USER_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_AVERAGE_USER_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_AVERAGE_CATEGORY_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_AVERAGE_CATEGORY_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_AVERAGE_AMOUNT_ASC
  TRANSACTIONS_BY_CATEGORY_ID_AVERAGE_AMOUNT_DESC
  TRANSACTIONS_BY_CATEGORY_ID_AVERAGE_DATE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_AVERAGE_DATE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_AVERAGE_DESCRIPTION_ASC
  TRANSACTIONS_BY_CATEGORY_ID_AVERAGE_DESCRIPTION_DESC
  TRANSACTIONS_BY_CATEGORY_ID_AVERAGE_TYPE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_AVERAGE_TYPE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_SAMPLE_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_SAMPLE_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_SAMPLE_USER_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_SAMPLE_USER_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_SAMPLE_CATEGORY_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_SAMPLE_CATEGORY_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_SAMPLE_AMOUNT_ASC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_SAMPLE_AMOUNT_DESC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_SAMPLE_DATE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_SAMPLE_DATE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_SAMPLE_DESCRIPTION_ASC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_SAMPLE_DESCRIPTION_DESC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_SAMPLE_TYPE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_SAMPLE_TYPE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_POPULATION_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_POPULATION_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_POPULATION_USER_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_POPULATION_USER_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_POPULATION_CATEGORY_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_POPULATION_CATEGORY_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_POPULATION_AMOUNT_ASC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_POPULATION_AMOUNT_DESC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_POPULATION_DATE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_POPULATION_DATE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_POPULATION_DESCRIPTION_ASC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_POPULATION_DESCRIPTION_DESC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_POPULATION_TYPE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_STDDEV_POPULATION_TYPE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_SAMPLE_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_SAMPLE_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_SAMPLE_USER_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_SAMPLE_USER_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_SAMPLE_CATEGORY_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_SAMPLE_CATEGORY_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_SAMPLE_AMOUNT_ASC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_SAMPLE_AMOUNT_DESC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_SAMPLE_DATE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_SAMPLE_DATE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_SAMPLE_DESCRIPTION_ASC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_SAMPLE_DESCRIPTION_DESC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_SAMPLE_TYPE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_SAMPLE_TYPE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_POPULATION_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_POPULATION_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_POPULATION_USER_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_POPULATION_USER_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_POPULATION_CATEGORY_ID_ASC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_POPULATION_CATEGORY_ID_DESC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_POPULATION_AMOUNT_ASC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_POPULATION_AMOUNT_DESC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_POPULATION_DATE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_POPULATION_DATE_DESC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_POPULATION_DESCRIPTION_ASC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_POPULATION_DESCRIPTION_DESC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_POPULATION_TYPE_ASC
  TRANSACTIONS_BY_CATEGORY_ID_VARIANCE_POPULATION_TYPE_DESC
  BUDGETS_BY_CATEGORY_ID_COUNT_ASC
  BUDGETS_BY_CATEGORY_ID_COUNT_DESC
  BUDGETS_BY_CATEGORY_ID_SUM_BUDGET_ID_ASC
  BUDGETS_BY_CATEGORY_ID_SUM_BUDGET_ID_DESC
  BUDGETS_BY_CATEGORY_ID_SUM_USER_ID_ASC
  BUDGETS_BY_CATEGORY_ID_SUM_USER_ID_DESC
  BUDGETS_BY_CATEGORY_ID_SUM_CATEGORY_ID_ASC
  BUDGETS_BY_CATEGORY_ID_SUM_CATEGORY_ID_DESC
  BUDGETS_BY_CATEGORY_ID_SUM_AMOUNT_ASC
  BUDGETS_BY_CATEGORY_ID_SUM_AMOUNT_DESC
  BUDGETS_BY_CATEGORY_ID_SUM_MONTH_ASC
  BUDGETS_BY_CATEGORY_ID_SUM_MONTH_DESC
  BUDGETS_BY_CATEGORY_ID_SUM_ALERT_THRESHOLD_ASC
  BUDGETS_BY_CATEGORY_ID_SUM_ALERT_THRESHOLD_DESC
  BUDGETS_BY_CATEGORY_ID_DISTINCT_COUNT_BUDGET_ID_ASC
  BUDGETS_BY_CATEGORY_ID_DISTINCT_COUNT_BUDGET_ID_DESC
  BUDGETS_BY_CATEGORY_ID_DISTINCT_COUNT_USER_ID_ASC
  BUDGETS_BY_CATEGORY_ID_DISTINCT_COUNT_USER_ID_DESC
  BUDGETS_BY_CATEGORY_ID_DISTINCT_COUNT_CATEGORY_ID_ASC
  BUDGETS_BY_CATEGORY_ID_DISTINCT_COUNT_CATEGORY_ID_DESC
  BUDGETS_BY_CATEGORY_ID_DISTINCT_COUNT_AMOUNT_ASC
  BUDGETS_BY_CATEGORY_ID_DISTINCT_COUNT_AMOUNT_DESC
  BUDGETS_BY_CATEGORY_ID_DISTINCT_COUNT_MONTH_ASC
  BUDGETS_BY_CATEGORY_ID_DISTINCT_COUNT_MONTH_DESC
  BUDGETS_BY_CATEGORY_ID_DISTINCT_COUNT_ALERT_THRESHOLD_ASC
  BUDGETS_BY_CATEGORY_ID_DISTINCT_COUNT_ALERT_THRESHOLD_DESC
  BUDGETS_BY_CATEGORY_ID_MIN_BUDGET_ID_ASC
  BUDGETS_BY_CATEGORY_ID_MIN_BUDGET_ID_DESC
  BUDGETS_BY_CATEGORY_ID_MIN_USER_ID_ASC
  BUDGETS_BY_CATEGORY_ID_MIN_USER_ID_DESC
  BUDGETS_BY_CATEGORY_ID_MIN_CATEGORY_ID_ASC
  BUDGETS_BY_CATEGORY_ID_MIN_CATEGORY_ID_DESC
  BUDGETS_BY_CATEGORY_ID_MIN_AMOUNT_ASC
  BUDGETS_BY_CATEGORY_ID_MIN_AMOUNT_DESC
  BUDGETS_BY_CATEGORY_ID_MIN_MONTH_ASC
  BUDGETS_BY_CATEGORY_ID_MIN_MONTH_DESC
  BUDGETS_BY_CATEGORY_ID_MIN_ALERT_THRESHOLD_ASC
  BUDGETS_BY_CATEGORY_ID_MIN_ALERT_THRESHOLD_DESC
  BUDGETS_BY_CATEGORY_ID_MAX_BUDGET_ID_ASC
  BUDGETS_BY_CATEGORY_ID_MAX_BUDGET_ID_DESC
  BUDGETS_BY_CATEGORY_ID_MAX_USER_ID_ASC
  BUDGETS_BY_CATEGORY_ID_MAX_USER_ID_DESC
  BUDGETS_BY_CATEGORY_ID_MAX_CATEGORY_ID_ASC
  BUDGETS_BY_CATEGORY_ID_MAX_CATEGORY_ID_DESC
  BUDGETS_BY_CATEGORY_ID_MAX_AMOUNT_ASC
  BUDGETS_BY_CATEGORY_ID_MAX_AMOUNT_DESC
  BUDGETS_BY_CATEGORY_ID_MAX_MONTH_ASC
  BUDGETS_BY_CATEGORY_ID_MAX_MONTH_DESC
  BUDGETS_BY_CATEGORY_ID_MAX_ALERT_THRESHOLD_ASC
  BUDGETS_BY_CATEGORY_ID_MAX_ALERT_THRESHOLD_DESC
  BUDGETS_BY_CATEGORY_ID_AVERAGE_BUDGET_ID_ASC
  BUDGETS_BY_CATEGORY_ID_AVERAGE_BUDGET_ID_DESC
  BUDGETS_BY_CATEGORY_ID_AVERAGE_USER_ID_ASC
  BUDGETS_BY_CATEGORY_ID_AVERAGE_USER_ID_DESC
  BUDGETS_BY_CATEGORY_ID_AVERAGE_CATEGORY_ID_ASC
  BUDGETS_BY_CATEGORY_ID_AVERAGE_CATEGORY_ID_DESC
  BUDGETS_BY_CATEGORY_ID_AVERAGE_AMOUNT_ASC
  BUDGETS_BY_CATEGORY_ID_AVERAGE_AMOUNT_DESC
  BUDGETS_BY_CATEGORY_ID_AVERAGE_MONTH_ASC
  BUDGETS_BY_CATEGORY_ID_AVERAGE_MONTH_DESC
  BUDGETS_BY_CATEGORY_ID_AVERAGE_ALERT_THRESHOLD_ASC
  BUDGETS_BY_CATEGORY_ID_AVERAGE_ALERT_THRESHOLD_DESC
  BUDGETS_BY_CATEGORY_ID_STDDEV_SAMPLE_BUDGET_ID_ASC
  BUDGETS_BY_CATEGORY_ID_STDDEV_SAMPLE_BUDGET_ID_DESC
  BUDGETS_BY_CATEGORY_ID_STDDEV_SAMPLE_USER_ID_ASC
  BUDGETS_BY_CATEGORY_ID_STDDEV_SAMPLE_USER_ID_DESC
  BUDGETS_BY_CATEGORY_ID_STDDEV_SAMPLE_CATEGORY_ID_ASC
  BUDGETS_BY_CATEGORY_ID_STDDEV_SAMPLE_CATEGORY_ID_DESC
  BUDGETS_BY_CATEGORY_ID_STDDEV_SAMPLE_AMOUNT_ASC
  BUDGETS_BY_CATEGORY_ID_STDDEV_SAMPLE_AMOUNT_DESC
  BUDGETS_BY_CATEGORY_ID_STDDEV_SAMPLE_MONTH_ASC
  BUDGETS_BY_CATEGORY_ID_STDDEV_SAMPLE_MONTH_DESC
  BUDGETS_BY_CATEGORY_ID_STDDEV_SAMPLE_ALERT_THRESHOLD_ASC
  BUDGETS_BY_CATEGORY_ID_STDDEV_SAMPLE_ALERT_THRESHOLD_DESC
  BUDGETS_BY_CATEGORY_ID_STDDEV_POPULATION_BUDGET_ID_ASC
  BUDGETS_BY_CATEGORY_ID_STDDEV_POPULATION_BUDGET_ID_DESC
  BUDGETS_BY_CATEGORY_ID_STDDEV_POPULATION_USER_ID_ASC
  BUDGETS_BY_CATEGORY_ID_STDDEV_POPULATION_USER_ID_DESC
  BUDGETS_BY_CATEGORY_ID_STDDEV_POPULATION_CATEGORY_ID_ASC
  BUDGETS_BY_CATEGORY_ID_STDDEV_POPULATION_CATEGORY_ID_DESC
  BUDGETS_BY_CATEGORY_ID_STDDEV_POPULATION_AMOUNT_ASC
  BUDGETS_BY_CATEGORY_ID_STDDEV_POPULATION_AMOUNT_DESC
  BUDGETS_BY_CATEGORY_ID_STDDEV_POPULATION_MONTH_ASC
  BUDGETS_BY_CATEGORY_ID_STDDEV_POPULATION_MONTH_DESC
  BUDGETS_BY_CATEGORY_ID_STDDEV_POPULATION_ALERT_THRESHOLD_ASC
  BUDGETS_BY_CATEGORY_ID_STDDEV_POPULATION_ALERT_THRESHOLD_DESC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_SAMPLE_BUDGET_ID_ASC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_SAMPLE_BUDGET_ID_DESC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_SAMPLE_USER_ID_ASC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_SAMPLE_USER_ID_DESC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_SAMPLE_CATEGORY_ID_ASC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_SAMPLE_CATEGORY_ID_DESC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_SAMPLE_AMOUNT_ASC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_SAMPLE_AMOUNT_DESC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_SAMPLE_MONTH_ASC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_SAMPLE_MONTH_DESC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_SAMPLE_ALERT_THRESHOLD_ASC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_SAMPLE_ALERT_THRESHOLD_DESC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_POPULATION_BUDGET_ID_ASC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_POPULATION_BUDGET_ID_DESC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_POPULATION_USER_ID_ASC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_POPULATION_USER_ID_DESC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_POPULATION_CATEGORY_ID_ASC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_POPULATION_CATEGORY_ID_DESC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_POPULATION_AMOUNT_ASC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_POPULATION_AMOUNT_DESC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_POPULATION_MONTH_ASC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_POPULATION_MONTH_DESC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_POPULATION_ALERT_THRESHOLD_ASC
  BUDGETS_BY_CATEGORY_ID_VARIANCE_POPULATION_ALERT_THRESHOLD_DESC
}

"""
A condition to be used against `Category` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CategoryCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""A connection to a list of `User` values."""
type UsersConnection {
  """A list of `User` objects."""
  nodes: [User!]!

  """
  A list of edges which contains the `User` and cursor to aid in pagination.
  """
  edges: [UsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: UserAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `User` for these aggregates."""
    groupBy: [UserGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: UserHavingInput
  ): [UserAggregates!]
}

"""A `User` edge in the connection."""
type UsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User!
}

type UserAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: UserDistinctCountAggregates
}

type UserDistinctCountAggregates {
  """Distinct count of oidcId across the matching connection"""
  oidcId: BigInt

  """Distinct count of firstName across the matching connection"""
  firstName: BigInt

  """Distinct count of lastName across the matching connection"""
  lastName: BigInt

  """Distinct count of gender across the matching connection"""
  gender: BigInt

  """Distinct count of email across the matching connection"""
  email: BigInt

  """Distinct count of tel across the matching connection"""
  tel: BigInt

  """Distinct count of picture across the matching connection"""
  picture: BigInt

  """Distinct count of password across the matching connection"""
  password: BigInt

  """Distinct count of date across the matching connection"""
  date: BigInt
}

"""Grouping methods for `User` for usage during aggregation."""
enum UserGroupBy {
  FIRST_NAME
  LAST_NAME
  GENDER
  EMAIL
  TEL
  PICTURE
  PASSWORD
  DATE
  DATE_TRUNCATED_TO_HOUR
  DATE_TRUNCATED_TO_DAY
}

"""Conditions for `User` aggregates."""
input UserHavingInput {
  AND: [UserHavingInput!]
  OR: [UserHavingInput!]
  sum: UserHavingSumInput
  distinctCount: UserHavingDistinctCountInput
  min: UserHavingMinInput
  max: UserHavingMaxInput
  average: UserHavingAverageInput
  stddevSample: UserHavingStddevSampleInput
  stddevPopulation: UserHavingStddevPopulationInput
  varianceSample: UserHavingVarianceSampleInput
  variancePopulation: UserHavingVariancePopulationInput
}

input UserHavingSumInput {
  date: HavingDatetimeFilter
}

input UserHavingDistinctCountInput {
  date: HavingDatetimeFilter
}

input UserHavingMinInput {
  date: HavingDatetimeFilter
}

input UserHavingMaxInput {
  date: HavingDatetimeFilter
}

input UserHavingAverageInput {
  date: HavingDatetimeFilter
}

input UserHavingStddevSampleInput {
  date: HavingDatetimeFilter
}

input UserHavingStddevPopulationInput {
  date: HavingDatetimeFilter
}

input UserHavingVarianceSampleInput {
  date: HavingDatetimeFilter
}

input UserHavingVariancePopulationInput {
  date: HavingDatetimeFilter
}

"""Methods to use when ordering `User`."""
enum UsersOrderBy {
  NATURAL
  OIDC_ID_ASC
  OIDC_ID_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  GENDER_ASC
  GENDER_DESC
  EMAIL_ASC
  EMAIL_DESC
  TEL_ASC
  TEL_DESC
  PICTURE_ASC
  PICTURE_DESC
  PASSWORD_ASC
  PASSWORD_DESC
  DATE_ASC
  DATE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_DEVICES_BY_USER_ID_COUNT_ASC
  USER_DEVICES_BY_USER_ID_COUNT_DESC
  USER_DEVICES_BY_USER_ID_SUM_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_SUM_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_SUM_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_SUM_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_SUM_UA_ASC
  USER_DEVICES_BY_USER_ID_SUM_UA_DESC
  USER_DEVICES_BY_USER_ID_DISTINCT_COUNT_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_DISTINCT_COUNT_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_DISTINCT_COUNT_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_DISTINCT_COUNT_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_DISTINCT_COUNT_UA_ASC
  USER_DEVICES_BY_USER_ID_DISTINCT_COUNT_UA_DESC
  USER_DEVICES_BY_USER_ID_MIN_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_MIN_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_MIN_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_MIN_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_MIN_UA_ASC
  USER_DEVICES_BY_USER_ID_MIN_UA_DESC
  USER_DEVICES_BY_USER_ID_MAX_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_MAX_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_MAX_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_MAX_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_MAX_UA_ASC
  USER_DEVICES_BY_USER_ID_MAX_UA_DESC
  USER_DEVICES_BY_USER_ID_AVERAGE_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_AVERAGE_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_AVERAGE_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_AVERAGE_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_AVERAGE_UA_ASC
  USER_DEVICES_BY_USER_ID_AVERAGE_UA_DESC
  USER_DEVICES_BY_USER_ID_STDDEV_SAMPLE_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_STDDEV_SAMPLE_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_STDDEV_SAMPLE_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_STDDEV_SAMPLE_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_STDDEV_SAMPLE_UA_ASC
  USER_DEVICES_BY_USER_ID_STDDEV_SAMPLE_UA_DESC
  USER_DEVICES_BY_USER_ID_STDDEV_POPULATION_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_STDDEV_POPULATION_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_STDDEV_POPULATION_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_STDDEV_POPULATION_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_STDDEV_POPULATION_UA_ASC
  USER_DEVICES_BY_USER_ID_STDDEV_POPULATION_UA_DESC
  USER_DEVICES_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_VARIANCE_SAMPLE_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_VARIANCE_SAMPLE_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_VARIANCE_SAMPLE_UA_ASC
  USER_DEVICES_BY_USER_ID_VARIANCE_SAMPLE_UA_DESC
  USER_DEVICES_BY_USER_ID_VARIANCE_POPULATION_USER_ID_ASC
  USER_DEVICES_BY_USER_ID_VARIANCE_POPULATION_USER_ID_DESC
  USER_DEVICES_BY_USER_ID_VARIANCE_POPULATION_TOKEN_ASC
  USER_DEVICES_BY_USER_ID_VARIANCE_POPULATION_TOKEN_DESC
  USER_DEVICES_BY_USER_ID_VARIANCE_POPULATION_UA_ASC
  USER_DEVICES_BY_USER_ID_VARIANCE_POPULATION_UA_DESC
  TRANSACTIONS_BY_USER_ID_COUNT_ASC
  TRANSACTIONS_BY_USER_ID_COUNT_DESC
  TRANSACTIONS_BY_USER_ID_SUM_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_USER_ID_SUM_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_USER_ID_SUM_USER_ID_ASC
  TRANSACTIONS_BY_USER_ID_SUM_USER_ID_DESC
  TRANSACTIONS_BY_USER_ID_SUM_CATEGORY_ID_ASC
  TRANSACTIONS_BY_USER_ID_SUM_CATEGORY_ID_DESC
  TRANSACTIONS_BY_USER_ID_SUM_AMOUNT_ASC
  TRANSACTIONS_BY_USER_ID_SUM_AMOUNT_DESC
  TRANSACTIONS_BY_USER_ID_SUM_DATE_ASC
  TRANSACTIONS_BY_USER_ID_SUM_DATE_DESC
  TRANSACTIONS_BY_USER_ID_SUM_DESCRIPTION_ASC
  TRANSACTIONS_BY_USER_ID_SUM_DESCRIPTION_DESC
  TRANSACTIONS_BY_USER_ID_SUM_TYPE_ASC
  TRANSACTIONS_BY_USER_ID_SUM_TYPE_DESC
  TRANSACTIONS_BY_USER_ID_DISTINCT_COUNT_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_USER_ID_DISTINCT_COUNT_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_USER_ID_DISTINCT_COUNT_USER_ID_ASC
  TRANSACTIONS_BY_USER_ID_DISTINCT_COUNT_USER_ID_DESC
  TRANSACTIONS_BY_USER_ID_DISTINCT_COUNT_CATEGORY_ID_ASC
  TRANSACTIONS_BY_USER_ID_DISTINCT_COUNT_CATEGORY_ID_DESC
  TRANSACTIONS_BY_USER_ID_DISTINCT_COUNT_AMOUNT_ASC
  TRANSACTIONS_BY_USER_ID_DISTINCT_COUNT_AMOUNT_DESC
  TRANSACTIONS_BY_USER_ID_DISTINCT_COUNT_DATE_ASC
  TRANSACTIONS_BY_USER_ID_DISTINCT_COUNT_DATE_DESC
  TRANSACTIONS_BY_USER_ID_DISTINCT_COUNT_DESCRIPTION_ASC
  TRANSACTIONS_BY_USER_ID_DISTINCT_COUNT_DESCRIPTION_DESC
  TRANSACTIONS_BY_USER_ID_DISTINCT_COUNT_TYPE_ASC
  TRANSACTIONS_BY_USER_ID_DISTINCT_COUNT_TYPE_DESC
  TRANSACTIONS_BY_USER_ID_MIN_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_USER_ID_MIN_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_USER_ID_MIN_USER_ID_ASC
  TRANSACTIONS_BY_USER_ID_MIN_USER_ID_DESC
  TRANSACTIONS_BY_USER_ID_MIN_CATEGORY_ID_ASC
  TRANSACTIONS_BY_USER_ID_MIN_CATEGORY_ID_DESC
  TRANSACTIONS_BY_USER_ID_MIN_AMOUNT_ASC
  TRANSACTIONS_BY_USER_ID_MIN_AMOUNT_DESC
  TRANSACTIONS_BY_USER_ID_MIN_DATE_ASC
  TRANSACTIONS_BY_USER_ID_MIN_DATE_DESC
  TRANSACTIONS_BY_USER_ID_MIN_DESCRIPTION_ASC
  TRANSACTIONS_BY_USER_ID_MIN_DESCRIPTION_DESC
  TRANSACTIONS_BY_USER_ID_MIN_TYPE_ASC
  TRANSACTIONS_BY_USER_ID_MIN_TYPE_DESC
  TRANSACTIONS_BY_USER_ID_MAX_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_USER_ID_MAX_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_USER_ID_MAX_USER_ID_ASC
  TRANSACTIONS_BY_USER_ID_MAX_USER_ID_DESC
  TRANSACTIONS_BY_USER_ID_MAX_CATEGORY_ID_ASC
  TRANSACTIONS_BY_USER_ID_MAX_CATEGORY_ID_DESC
  TRANSACTIONS_BY_USER_ID_MAX_AMOUNT_ASC
  TRANSACTIONS_BY_USER_ID_MAX_AMOUNT_DESC
  TRANSACTIONS_BY_USER_ID_MAX_DATE_ASC
  TRANSACTIONS_BY_USER_ID_MAX_DATE_DESC
  TRANSACTIONS_BY_USER_ID_MAX_DESCRIPTION_ASC
  TRANSACTIONS_BY_USER_ID_MAX_DESCRIPTION_DESC
  TRANSACTIONS_BY_USER_ID_MAX_TYPE_ASC
  TRANSACTIONS_BY_USER_ID_MAX_TYPE_DESC
  TRANSACTIONS_BY_USER_ID_AVERAGE_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_USER_ID_AVERAGE_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_USER_ID_AVERAGE_USER_ID_ASC
  TRANSACTIONS_BY_USER_ID_AVERAGE_USER_ID_DESC
  TRANSACTIONS_BY_USER_ID_AVERAGE_CATEGORY_ID_ASC
  TRANSACTIONS_BY_USER_ID_AVERAGE_CATEGORY_ID_DESC
  TRANSACTIONS_BY_USER_ID_AVERAGE_AMOUNT_ASC
  TRANSACTIONS_BY_USER_ID_AVERAGE_AMOUNT_DESC
  TRANSACTIONS_BY_USER_ID_AVERAGE_DATE_ASC
  TRANSACTIONS_BY_USER_ID_AVERAGE_DATE_DESC
  TRANSACTIONS_BY_USER_ID_AVERAGE_DESCRIPTION_ASC
  TRANSACTIONS_BY_USER_ID_AVERAGE_DESCRIPTION_DESC
  TRANSACTIONS_BY_USER_ID_AVERAGE_TYPE_ASC
  TRANSACTIONS_BY_USER_ID_AVERAGE_TYPE_DESC
  TRANSACTIONS_BY_USER_ID_STDDEV_SAMPLE_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_USER_ID_STDDEV_SAMPLE_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_USER_ID_STDDEV_SAMPLE_USER_ID_ASC
  TRANSACTIONS_BY_USER_ID_STDDEV_SAMPLE_USER_ID_DESC
  TRANSACTIONS_BY_USER_ID_STDDEV_SAMPLE_CATEGORY_ID_ASC
  TRANSACTIONS_BY_USER_ID_STDDEV_SAMPLE_CATEGORY_ID_DESC
  TRANSACTIONS_BY_USER_ID_STDDEV_SAMPLE_AMOUNT_ASC
  TRANSACTIONS_BY_USER_ID_STDDEV_SAMPLE_AMOUNT_DESC
  TRANSACTIONS_BY_USER_ID_STDDEV_SAMPLE_DATE_ASC
  TRANSACTIONS_BY_USER_ID_STDDEV_SAMPLE_DATE_DESC
  TRANSACTIONS_BY_USER_ID_STDDEV_SAMPLE_DESCRIPTION_ASC
  TRANSACTIONS_BY_USER_ID_STDDEV_SAMPLE_DESCRIPTION_DESC
  TRANSACTIONS_BY_USER_ID_STDDEV_SAMPLE_TYPE_ASC
  TRANSACTIONS_BY_USER_ID_STDDEV_SAMPLE_TYPE_DESC
  TRANSACTIONS_BY_USER_ID_STDDEV_POPULATION_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_USER_ID_STDDEV_POPULATION_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_USER_ID_STDDEV_POPULATION_USER_ID_ASC
  TRANSACTIONS_BY_USER_ID_STDDEV_POPULATION_USER_ID_DESC
  TRANSACTIONS_BY_USER_ID_STDDEV_POPULATION_CATEGORY_ID_ASC
  TRANSACTIONS_BY_USER_ID_STDDEV_POPULATION_CATEGORY_ID_DESC
  TRANSACTIONS_BY_USER_ID_STDDEV_POPULATION_AMOUNT_ASC
  TRANSACTIONS_BY_USER_ID_STDDEV_POPULATION_AMOUNT_DESC
  TRANSACTIONS_BY_USER_ID_STDDEV_POPULATION_DATE_ASC
  TRANSACTIONS_BY_USER_ID_STDDEV_POPULATION_DATE_DESC
  TRANSACTIONS_BY_USER_ID_STDDEV_POPULATION_DESCRIPTION_ASC
  TRANSACTIONS_BY_USER_ID_STDDEV_POPULATION_DESCRIPTION_DESC
  TRANSACTIONS_BY_USER_ID_STDDEV_POPULATION_TYPE_ASC
  TRANSACTIONS_BY_USER_ID_STDDEV_POPULATION_TYPE_DESC
  TRANSACTIONS_BY_USER_ID_VARIANCE_SAMPLE_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_USER_ID_VARIANCE_SAMPLE_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_ASC
  TRANSACTIONS_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_DESC
  TRANSACTIONS_BY_USER_ID_VARIANCE_SAMPLE_CATEGORY_ID_ASC
  TRANSACTIONS_BY_USER_ID_VARIANCE_SAMPLE_CATEGORY_ID_DESC
  TRANSACTIONS_BY_USER_ID_VARIANCE_SAMPLE_AMOUNT_ASC
  TRANSACTIONS_BY_USER_ID_VARIANCE_SAMPLE_AMOUNT_DESC
  TRANSACTIONS_BY_USER_ID_VARIANCE_SAMPLE_DATE_ASC
  TRANSACTIONS_BY_USER_ID_VARIANCE_SAMPLE_DATE_DESC
  TRANSACTIONS_BY_USER_ID_VARIANCE_SAMPLE_DESCRIPTION_ASC
  TRANSACTIONS_BY_USER_ID_VARIANCE_SAMPLE_DESCRIPTION_DESC
  TRANSACTIONS_BY_USER_ID_VARIANCE_SAMPLE_TYPE_ASC
  TRANSACTIONS_BY_USER_ID_VARIANCE_SAMPLE_TYPE_DESC
  TRANSACTIONS_BY_USER_ID_VARIANCE_POPULATION_TRANSACTION_ID_ASC
  TRANSACTIONS_BY_USER_ID_VARIANCE_POPULATION_TRANSACTION_ID_DESC
  TRANSACTIONS_BY_USER_ID_VARIANCE_POPULATION_USER_ID_ASC
  TRANSACTIONS_BY_USER_ID_VARIANCE_POPULATION_USER_ID_DESC
  TRANSACTIONS_BY_USER_ID_VARIANCE_POPULATION_CATEGORY_ID_ASC
  TRANSACTIONS_BY_USER_ID_VARIANCE_POPULATION_CATEGORY_ID_DESC
  TRANSACTIONS_BY_USER_ID_VARIANCE_POPULATION_AMOUNT_ASC
  TRANSACTIONS_BY_USER_ID_VARIANCE_POPULATION_AMOUNT_DESC
  TRANSACTIONS_BY_USER_ID_VARIANCE_POPULATION_DATE_ASC
  TRANSACTIONS_BY_USER_ID_VARIANCE_POPULATION_DATE_DESC
  TRANSACTIONS_BY_USER_ID_VARIANCE_POPULATION_DESCRIPTION_ASC
  TRANSACTIONS_BY_USER_ID_VARIANCE_POPULATION_DESCRIPTION_DESC
  TRANSACTIONS_BY_USER_ID_VARIANCE_POPULATION_TYPE_ASC
  TRANSACTIONS_BY_USER_ID_VARIANCE_POPULATION_TYPE_DESC
  BUDGETS_BY_USER_ID_COUNT_ASC
  BUDGETS_BY_USER_ID_COUNT_DESC
  BUDGETS_BY_USER_ID_SUM_BUDGET_ID_ASC
  BUDGETS_BY_USER_ID_SUM_BUDGET_ID_DESC
  BUDGETS_BY_USER_ID_SUM_USER_ID_ASC
  BUDGETS_BY_USER_ID_SUM_USER_ID_DESC
  BUDGETS_BY_USER_ID_SUM_CATEGORY_ID_ASC
  BUDGETS_BY_USER_ID_SUM_CATEGORY_ID_DESC
  BUDGETS_BY_USER_ID_SUM_AMOUNT_ASC
  BUDGETS_BY_USER_ID_SUM_AMOUNT_DESC
  BUDGETS_BY_USER_ID_SUM_MONTH_ASC
  BUDGETS_BY_USER_ID_SUM_MONTH_DESC
  BUDGETS_BY_USER_ID_SUM_ALERT_THRESHOLD_ASC
  BUDGETS_BY_USER_ID_SUM_ALERT_THRESHOLD_DESC
  BUDGETS_BY_USER_ID_DISTINCT_COUNT_BUDGET_ID_ASC
  BUDGETS_BY_USER_ID_DISTINCT_COUNT_BUDGET_ID_DESC
  BUDGETS_BY_USER_ID_DISTINCT_COUNT_USER_ID_ASC
  BUDGETS_BY_USER_ID_DISTINCT_COUNT_USER_ID_DESC
  BUDGETS_BY_USER_ID_DISTINCT_COUNT_CATEGORY_ID_ASC
  BUDGETS_BY_USER_ID_DISTINCT_COUNT_CATEGORY_ID_DESC
  BUDGETS_BY_USER_ID_DISTINCT_COUNT_AMOUNT_ASC
  BUDGETS_BY_USER_ID_DISTINCT_COUNT_AMOUNT_DESC
  BUDGETS_BY_USER_ID_DISTINCT_COUNT_MONTH_ASC
  BUDGETS_BY_USER_ID_DISTINCT_COUNT_MONTH_DESC
  BUDGETS_BY_USER_ID_DISTINCT_COUNT_ALERT_THRESHOLD_ASC
  BUDGETS_BY_USER_ID_DISTINCT_COUNT_ALERT_THRESHOLD_DESC
  BUDGETS_BY_USER_ID_MIN_BUDGET_ID_ASC
  BUDGETS_BY_USER_ID_MIN_BUDGET_ID_DESC
  BUDGETS_BY_USER_ID_MIN_USER_ID_ASC
  BUDGETS_BY_USER_ID_MIN_USER_ID_DESC
  BUDGETS_BY_USER_ID_MIN_CATEGORY_ID_ASC
  BUDGETS_BY_USER_ID_MIN_CATEGORY_ID_DESC
  BUDGETS_BY_USER_ID_MIN_AMOUNT_ASC
  BUDGETS_BY_USER_ID_MIN_AMOUNT_DESC
  BUDGETS_BY_USER_ID_MIN_MONTH_ASC
  BUDGETS_BY_USER_ID_MIN_MONTH_DESC
  BUDGETS_BY_USER_ID_MIN_ALERT_THRESHOLD_ASC
  BUDGETS_BY_USER_ID_MIN_ALERT_THRESHOLD_DESC
  BUDGETS_BY_USER_ID_MAX_BUDGET_ID_ASC
  BUDGETS_BY_USER_ID_MAX_BUDGET_ID_DESC
  BUDGETS_BY_USER_ID_MAX_USER_ID_ASC
  BUDGETS_BY_USER_ID_MAX_USER_ID_DESC
  BUDGETS_BY_USER_ID_MAX_CATEGORY_ID_ASC
  BUDGETS_BY_USER_ID_MAX_CATEGORY_ID_DESC
  BUDGETS_BY_USER_ID_MAX_AMOUNT_ASC
  BUDGETS_BY_USER_ID_MAX_AMOUNT_DESC
  BUDGETS_BY_USER_ID_MAX_MONTH_ASC
  BUDGETS_BY_USER_ID_MAX_MONTH_DESC
  BUDGETS_BY_USER_ID_MAX_ALERT_THRESHOLD_ASC
  BUDGETS_BY_USER_ID_MAX_ALERT_THRESHOLD_DESC
  BUDGETS_BY_USER_ID_AVERAGE_BUDGET_ID_ASC
  BUDGETS_BY_USER_ID_AVERAGE_BUDGET_ID_DESC
  BUDGETS_BY_USER_ID_AVERAGE_USER_ID_ASC
  BUDGETS_BY_USER_ID_AVERAGE_USER_ID_DESC
  BUDGETS_BY_USER_ID_AVERAGE_CATEGORY_ID_ASC
  BUDGETS_BY_USER_ID_AVERAGE_CATEGORY_ID_DESC
  BUDGETS_BY_USER_ID_AVERAGE_AMOUNT_ASC
  BUDGETS_BY_USER_ID_AVERAGE_AMOUNT_DESC
  BUDGETS_BY_USER_ID_AVERAGE_MONTH_ASC
  BUDGETS_BY_USER_ID_AVERAGE_MONTH_DESC
  BUDGETS_BY_USER_ID_AVERAGE_ALERT_THRESHOLD_ASC
  BUDGETS_BY_USER_ID_AVERAGE_ALERT_THRESHOLD_DESC
  BUDGETS_BY_USER_ID_STDDEV_SAMPLE_BUDGET_ID_ASC
  BUDGETS_BY_USER_ID_STDDEV_SAMPLE_BUDGET_ID_DESC
  BUDGETS_BY_USER_ID_STDDEV_SAMPLE_USER_ID_ASC
  BUDGETS_BY_USER_ID_STDDEV_SAMPLE_USER_ID_DESC
  BUDGETS_BY_USER_ID_STDDEV_SAMPLE_CATEGORY_ID_ASC
  BUDGETS_BY_USER_ID_STDDEV_SAMPLE_CATEGORY_ID_DESC
  BUDGETS_BY_USER_ID_STDDEV_SAMPLE_AMOUNT_ASC
  BUDGETS_BY_USER_ID_STDDEV_SAMPLE_AMOUNT_DESC
  BUDGETS_BY_USER_ID_STDDEV_SAMPLE_MONTH_ASC
  BUDGETS_BY_USER_ID_STDDEV_SAMPLE_MONTH_DESC
  BUDGETS_BY_USER_ID_STDDEV_SAMPLE_ALERT_THRESHOLD_ASC
  BUDGETS_BY_USER_ID_STDDEV_SAMPLE_ALERT_THRESHOLD_DESC
  BUDGETS_BY_USER_ID_STDDEV_POPULATION_BUDGET_ID_ASC
  BUDGETS_BY_USER_ID_STDDEV_POPULATION_BUDGET_ID_DESC
  BUDGETS_BY_USER_ID_STDDEV_POPULATION_USER_ID_ASC
  BUDGETS_BY_USER_ID_STDDEV_POPULATION_USER_ID_DESC
  BUDGETS_BY_USER_ID_STDDEV_POPULATION_CATEGORY_ID_ASC
  BUDGETS_BY_USER_ID_STDDEV_POPULATION_CATEGORY_ID_DESC
  BUDGETS_BY_USER_ID_STDDEV_POPULATION_AMOUNT_ASC
  BUDGETS_BY_USER_ID_STDDEV_POPULATION_AMOUNT_DESC
  BUDGETS_BY_USER_ID_STDDEV_POPULATION_MONTH_ASC
  BUDGETS_BY_USER_ID_STDDEV_POPULATION_MONTH_DESC
  BUDGETS_BY_USER_ID_STDDEV_POPULATION_ALERT_THRESHOLD_ASC
  BUDGETS_BY_USER_ID_STDDEV_POPULATION_ALERT_THRESHOLD_DESC
  BUDGETS_BY_USER_ID_VARIANCE_SAMPLE_BUDGET_ID_ASC
  BUDGETS_BY_USER_ID_VARIANCE_SAMPLE_BUDGET_ID_DESC
  BUDGETS_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_ASC
  BUDGETS_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_DESC
  BUDGETS_BY_USER_ID_VARIANCE_SAMPLE_CATEGORY_ID_ASC
  BUDGETS_BY_USER_ID_VARIANCE_SAMPLE_CATEGORY_ID_DESC
  BUDGETS_BY_USER_ID_VARIANCE_SAMPLE_AMOUNT_ASC
  BUDGETS_BY_USER_ID_VARIANCE_SAMPLE_AMOUNT_DESC
  BUDGETS_BY_USER_ID_VARIANCE_SAMPLE_MONTH_ASC
  BUDGETS_BY_USER_ID_VARIANCE_SAMPLE_MONTH_DESC
  BUDGETS_BY_USER_ID_VARIANCE_SAMPLE_ALERT_THRESHOLD_ASC
  BUDGETS_BY_USER_ID_VARIANCE_SAMPLE_ALERT_THRESHOLD_DESC
  BUDGETS_BY_USER_ID_VARIANCE_POPULATION_BUDGET_ID_ASC
  BUDGETS_BY_USER_ID_VARIANCE_POPULATION_BUDGET_ID_DESC
  BUDGETS_BY_USER_ID_VARIANCE_POPULATION_USER_ID_ASC
  BUDGETS_BY_USER_ID_VARIANCE_POPULATION_USER_ID_DESC
  BUDGETS_BY_USER_ID_VARIANCE_POPULATION_CATEGORY_ID_ASC
  BUDGETS_BY_USER_ID_VARIANCE_POPULATION_CATEGORY_ID_DESC
  BUDGETS_BY_USER_ID_VARIANCE_POPULATION_AMOUNT_ASC
  BUDGETS_BY_USER_ID_VARIANCE_POPULATION_AMOUNT_DESC
  BUDGETS_BY_USER_ID_VARIANCE_POPULATION_MONTH_ASC
  BUDGETS_BY_USER_ID_VARIANCE_POPULATION_MONTH_DESC
  BUDGETS_BY_USER_ID_VARIANCE_POPULATION_ALERT_THRESHOLD_ASC
  BUDGETS_BY_USER_ID_VARIANCE_POPULATION_ALERT_THRESHOLD_DESC
  REPORTS_BY_USER_ID_COUNT_ASC
  REPORTS_BY_USER_ID_COUNT_DESC
  REPORTS_BY_USER_ID_SUM_REPORT_ID_ASC
  REPORTS_BY_USER_ID_SUM_REPORT_ID_DESC
  REPORTS_BY_USER_ID_SUM_USER_ID_ASC
  REPORTS_BY_USER_ID_SUM_USER_ID_DESC
  REPORTS_BY_USER_ID_SUM_CREATED_AT_ASC
  REPORTS_BY_USER_ID_SUM_CREATED_AT_DESC
  REPORTS_BY_USER_ID_SUM_FILE_PATH_ASC
  REPORTS_BY_USER_ID_SUM_FILE_PATH_DESC
  REPORTS_BY_USER_ID_DISTINCT_COUNT_REPORT_ID_ASC
  REPORTS_BY_USER_ID_DISTINCT_COUNT_REPORT_ID_DESC
  REPORTS_BY_USER_ID_DISTINCT_COUNT_USER_ID_ASC
  REPORTS_BY_USER_ID_DISTINCT_COUNT_USER_ID_DESC
  REPORTS_BY_USER_ID_DISTINCT_COUNT_CREATED_AT_ASC
  REPORTS_BY_USER_ID_DISTINCT_COUNT_CREATED_AT_DESC
  REPORTS_BY_USER_ID_DISTINCT_COUNT_FILE_PATH_ASC
  REPORTS_BY_USER_ID_DISTINCT_COUNT_FILE_PATH_DESC
  REPORTS_BY_USER_ID_MIN_REPORT_ID_ASC
  REPORTS_BY_USER_ID_MIN_REPORT_ID_DESC
  REPORTS_BY_USER_ID_MIN_USER_ID_ASC
  REPORTS_BY_USER_ID_MIN_USER_ID_DESC
  REPORTS_BY_USER_ID_MIN_CREATED_AT_ASC
  REPORTS_BY_USER_ID_MIN_CREATED_AT_DESC
  REPORTS_BY_USER_ID_MIN_FILE_PATH_ASC
  REPORTS_BY_USER_ID_MIN_FILE_PATH_DESC
  REPORTS_BY_USER_ID_MAX_REPORT_ID_ASC
  REPORTS_BY_USER_ID_MAX_REPORT_ID_DESC
  REPORTS_BY_USER_ID_MAX_USER_ID_ASC
  REPORTS_BY_USER_ID_MAX_USER_ID_DESC
  REPORTS_BY_USER_ID_MAX_CREATED_AT_ASC
  REPORTS_BY_USER_ID_MAX_CREATED_AT_DESC
  REPORTS_BY_USER_ID_MAX_FILE_PATH_ASC
  REPORTS_BY_USER_ID_MAX_FILE_PATH_DESC
  REPORTS_BY_USER_ID_AVERAGE_REPORT_ID_ASC
  REPORTS_BY_USER_ID_AVERAGE_REPORT_ID_DESC
  REPORTS_BY_USER_ID_AVERAGE_USER_ID_ASC
  REPORTS_BY_USER_ID_AVERAGE_USER_ID_DESC
  REPORTS_BY_USER_ID_AVERAGE_CREATED_AT_ASC
  REPORTS_BY_USER_ID_AVERAGE_CREATED_AT_DESC
  REPORTS_BY_USER_ID_AVERAGE_FILE_PATH_ASC
  REPORTS_BY_USER_ID_AVERAGE_FILE_PATH_DESC
  REPORTS_BY_USER_ID_STDDEV_SAMPLE_REPORT_ID_ASC
  REPORTS_BY_USER_ID_STDDEV_SAMPLE_REPORT_ID_DESC
  REPORTS_BY_USER_ID_STDDEV_SAMPLE_USER_ID_ASC
  REPORTS_BY_USER_ID_STDDEV_SAMPLE_USER_ID_DESC
  REPORTS_BY_USER_ID_STDDEV_SAMPLE_CREATED_AT_ASC
  REPORTS_BY_USER_ID_STDDEV_SAMPLE_CREATED_AT_DESC
  REPORTS_BY_USER_ID_STDDEV_SAMPLE_FILE_PATH_ASC
  REPORTS_BY_USER_ID_STDDEV_SAMPLE_FILE_PATH_DESC
  REPORTS_BY_USER_ID_STDDEV_POPULATION_REPORT_ID_ASC
  REPORTS_BY_USER_ID_STDDEV_POPULATION_REPORT_ID_DESC
  REPORTS_BY_USER_ID_STDDEV_POPULATION_USER_ID_ASC
  REPORTS_BY_USER_ID_STDDEV_POPULATION_USER_ID_DESC
  REPORTS_BY_USER_ID_STDDEV_POPULATION_CREATED_AT_ASC
  REPORTS_BY_USER_ID_STDDEV_POPULATION_CREATED_AT_DESC
  REPORTS_BY_USER_ID_STDDEV_POPULATION_FILE_PATH_ASC
  REPORTS_BY_USER_ID_STDDEV_POPULATION_FILE_PATH_DESC
  REPORTS_BY_USER_ID_VARIANCE_SAMPLE_REPORT_ID_ASC
  REPORTS_BY_USER_ID_VARIANCE_SAMPLE_REPORT_ID_DESC
  REPORTS_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_ASC
  REPORTS_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_DESC
  REPORTS_BY_USER_ID_VARIANCE_SAMPLE_CREATED_AT_ASC
  REPORTS_BY_USER_ID_VARIANCE_SAMPLE_CREATED_AT_DESC
  REPORTS_BY_USER_ID_VARIANCE_SAMPLE_FILE_PATH_ASC
  REPORTS_BY_USER_ID_VARIANCE_SAMPLE_FILE_PATH_DESC
  REPORTS_BY_USER_ID_VARIANCE_POPULATION_REPORT_ID_ASC
  REPORTS_BY_USER_ID_VARIANCE_POPULATION_REPORT_ID_DESC
  REPORTS_BY_USER_ID_VARIANCE_POPULATION_USER_ID_ASC
  REPORTS_BY_USER_ID_VARIANCE_POPULATION_USER_ID_DESC
  REPORTS_BY_USER_ID_VARIANCE_POPULATION_CREATED_AT_ASC
  REPORTS_BY_USER_ID_VARIANCE_POPULATION_CREATED_AT_DESC
  REPORTS_BY_USER_ID_VARIANCE_POPULATION_FILE_PATH_ASC
  REPORTS_BY_USER_ID_VARIANCE_POPULATION_FILE_PATH_DESC
  OTP_VERIFICATIONS_BY_USER_ID_COUNT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_COUNT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_SUM_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_SUM_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_SUM_USER_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_SUM_USER_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_SUM_OTP_ASC
  OTP_VERIFICATIONS_BY_USER_ID_SUM_OTP_DESC
  OTP_VERIFICATIONS_BY_USER_ID_SUM_EXPIRES_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_SUM_EXPIRES_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_SUM_CREATED_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_SUM_CREATED_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_SUM_EMAIL_ASC
  OTP_VERIFICATIONS_BY_USER_ID_SUM_EMAIL_DESC
  OTP_VERIFICATIONS_BY_USER_ID_DISTINCT_COUNT_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_DISTINCT_COUNT_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_DISTINCT_COUNT_USER_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_DISTINCT_COUNT_USER_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_DISTINCT_COUNT_OTP_ASC
  OTP_VERIFICATIONS_BY_USER_ID_DISTINCT_COUNT_OTP_DESC
  OTP_VERIFICATIONS_BY_USER_ID_DISTINCT_COUNT_EXPIRES_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_DISTINCT_COUNT_EXPIRES_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_DISTINCT_COUNT_CREATED_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_DISTINCT_COUNT_CREATED_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_DISTINCT_COUNT_EMAIL_ASC
  OTP_VERIFICATIONS_BY_USER_ID_DISTINCT_COUNT_EMAIL_DESC
  OTP_VERIFICATIONS_BY_USER_ID_MIN_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_MIN_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_MIN_USER_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_MIN_USER_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_MIN_OTP_ASC
  OTP_VERIFICATIONS_BY_USER_ID_MIN_OTP_DESC
  OTP_VERIFICATIONS_BY_USER_ID_MIN_EXPIRES_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_MIN_EXPIRES_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_MIN_CREATED_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_MIN_CREATED_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_MIN_EMAIL_ASC
  OTP_VERIFICATIONS_BY_USER_ID_MIN_EMAIL_DESC
  OTP_VERIFICATIONS_BY_USER_ID_MAX_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_MAX_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_MAX_USER_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_MAX_USER_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_MAX_OTP_ASC
  OTP_VERIFICATIONS_BY_USER_ID_MAX_OTP_DESC
  OTP_VERIFICATIONS_BY_USER_ID_MAX_EXPIRES_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_MAX_EXPIRES_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_MAX_CREATED_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_MAX_CREATED_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_MAX_EMAIL_ASC
  OTP_VERIFICATIONS_BY_USER_ID_MAX_EMAIL_DESC
  OTP_VERIFICATIONS_BY_USER_ID_AVERAGE_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_AVERAGE_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_AVERAGE_USER_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_AVERAGE_USER_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_AVERAGE_OTP_ASC
  OTP_VERIFICATIONS_BY_USER_ID_AVERAGE_OTP_DESC
  OTP_VERIFICATIONS_BY_USER_ID_AVERAGE_EXPIRES_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_AVERAGE_EXPIRES_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_AVERAGE_CREATED_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_AVERAGE_CREATED_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_AVERAGE_EMAIL_ASC
  OTP_VERIFICATIONS_BY_USER_ID_AVERAGE_EMAIL_DESC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_SAMPLE_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_SAMPLE_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_SAMPLE_USER_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_SAMPLE_USER_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_SAMPLE_OTP_ASC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_SAMPLE_OTP_DESC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_SAMPLE_EXPIRES_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_SAMPLE_EXPIRES_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_SAMPLE_CREATED_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_SAMPLE_CREATED_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_SAMPLE_EMAIL_ASC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_SAMPLE_EMAIL_DESC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_POPULATION_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_POPULATION_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_POPULATION_USER_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_POPULATION_USER_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_POPULATION_OTP_ASC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_POPULATION_OTP_DESC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_POPULATION_EXPIRES_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_POPULATION_EXPIRES_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_POPULATION_CREATED_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_POPULATION_CREATED_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_POPULATION_EMAIL_ASC
  OTP_VERIFICATIONS_BY_USER_ID_STDDEV_POPULATION_EMAIL_DESC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_SAMPLE_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_SAMPLE_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_SAMPLE_OTP_ASC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_SAMPLE_OTP_DESC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_SAMPLE_EXPIRES_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_SAMPLE_EXPIRES_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_SAMPLE_CREATED_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_SAMPLE_CREATED_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_SAMPLE_EMAIL_ASC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_SAMPLE_EMAIL_DESC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_POPULATION_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_POPULATION_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_POPULATION_USER_ID_ASC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_POPULATION_USER_ID_DESC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_POPULATION_OTP_ASC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_POPULATION_OTP_DESC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_POPULATION_EXPIRES_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_POPULATION_EXPIRES_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_POPULATION_CREATED_AT_ASC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_POPULATION_CREATED_AT_DESC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_POPULATION_EMAIL_ASC
  OTP_VERIFICATIONS_BY_USER_ID_VARIANCE_POPULATION_EMAIL_DESC
}

"""
A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input UserCondition {
  """Checks for equality with the object’s `oidcId` field."""
  oidcId: String

  """Checks for equality with the object’s `firstName` field."""
  firstName: String

  """Checks for equality with the object’s `lastName` field."""
  lastName: String

  """Checks for equality with the object’s `gender` field."""
  gender: UserGender

  """Checks for equality with the object’s `email` field."""
  email: String

  """Checks for equality with the object’s `tel` field."""
  tel: String

  """Checks for equality with the object’s `picture` field."""
  picture: String

  """Checks for equality with the object’s `password` field."""
  password: String

  """Checks for equality with the object’s `date` field."""
  date: Datetime
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `Budget`."""
  createBudget(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateBudgetInput!
  ): CreateBudgetPayload

  """Creates a single `Category`."""
  createCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCategoryInput!
  ): CreateCategoryPayload

  """Creates a single `OtpVerification`."""
  createOtpVerification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateOtpVerificationInput!
  ): CreateOtpVerificationPayload

  """Creates a single `Report`."""
  createReport(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateReportInput!
  ): CreateReportPayload

  """Creates a single `Transaction`."""
  createTransaction(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTransactionInput!
  ): CreateTransactionPayload

  """Creates a single `User`."""
  createUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserInput!
  ): CreateUserPayload

  """Creates a single `UserDevice`."""
  createUserDevice(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserDeviceInput!
  ): CreateUserDevicePayload

  """Updates a single `Budget` using its globally unique id and a patch."""
  updateBudgetByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateBudgetByNodeIdInput!
  ): UpdateBudgetPayload

  """Updates a single `Budget` using a unique key and a patch."""
  updateBudget(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateBudgetInput!
  ): UpdateBudgetPayload

  """Updates a single `Category` using its globally unique id and a patch."""
  updateCategoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCategoryByNodeIdInput!
  ): UpdateCategoryPayload

  """Updates a single `Category` using a unique key and a patch."""
  updateCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCategoryInput!
  ): UpdateCategoryPayload

  """
  Updates a single `OtpVerification` using its globally unique id and a patch.
  """
  updateOtpVerificationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOtpVerificationByNodeIdInput!
  ): UpdateOtpVerificationPayload

  """Updates a single `OtpVerification` using a unique key and a patch."""
  updateOtpVerification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOtpVerificationInput!
  ): UpdateOtpVerificationPayload

  """Updates a single `Report` using its globally unique id and a patch."""
  updateReportByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateReportByNodeIdInput!
  ): UpdateReportPayload

  """Updates a single `Report` using a unique key and a patch."""
  updateReport(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateReportInput!
  ): UpdateReportPayload

  """
  Updates a single `Transaction` using its globally unique id and a patch.
  """
  updateTransactionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTransactionByNodeIdInput!
  ): UpdateTransactionPayload

  """Updates a single `Transaction` using a unique key and a patch."""
  updateTransaction(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTransactionInput!
  ): UpdateTransactionPayload

  """Updates a single `User` using its globally unique id and a patch."""
  updateUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserByNodeIdInput!
  ): UpdateUserPayload

  """Updates a single `User` using a unique key and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload

  """
  Updates a single `UserDevice` using its globally unique id and a patch.
  """
  updateUserDeviceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserDeviceByNodeIdInput!
  ): UpdateUserDevicePayload

  """Updates a single `UserDevice` using a unique key and a patch."""
  updateUserDevice(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserDeviceInput!
  ): UpdateUserDevicePayload

  """Updates a single `UserDevice` using a unique key and a patch."""
  updateUserDeviceByToken(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserDeviceByTokenInput!
  ): UpdateUserDevicePayload

  """Deletes a single `Budget` using its globally unique id."""
  deleteBudgetByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteBudgetByNodeIdInput!
  ): DeleteBudgetPayload

  """Deletes a single `Budget` using a unique key."""
  deleteBudget(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteBudgetInput!
  ): DeleteBudgetPayload

  """Deletes a single `Category` using its globally unique id."""
  deleteCategoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCategoryByNodeIdInput!
  ): DeleteCategoryPayload

  """Deletes a single `Category` using a unique key."""
  deleteCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCategoryInput!
  ): DeleteCategoryPayload

  """Deletes a single `OtpVerification` using its globally unique id."""
  deleteOtpVerificationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOtpVerificationByNodeIdInput!
  ): DeleteOtpVerificationPayload

  """Deletes a single `OtpVerification` using a unique key."""
  deleteOtpVerification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOtpVerificationInput!
  ): DeleteOtpVerificationPayload

  """Deletes a single `Report` using its globally unique id."""
  deleteReportByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteReportByNodeIdInput!
  ): DeleteReportPayload

  """Deletes a single `Report` using a unique key."""
  deleteReport(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteReportInput!
  ): DeleteReportPayload

  """Deletes a single `Transaction` using its globally unique id."""
  deleteTransactionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTransactionByNodeIdInput!
  ): DeleteTransactionPayload

  """Deletes a single `Transaction` using a unique key."""
  deleteTransaction(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTransactionInput!
  ): DeleteTransactionPayload

  """Deletes a single `User` using its globally unique id."""
  deleteUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserByNodeIdInput!
  ): DeleteUserPayload

  """Deletes a single `User` using a unique key."""
  deleteUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserInput!
  ): DeleteUserPayload

  """Deletes a single `UserDevice` using its globally unique id."""
  deleteUserDeviceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserDeviceByNodeIdInput!
  ): DeleteUserDevicePayload

  """Deletes a single `UserDevice` using a unique key."""
  deleteUserDevice(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserDeviceInput!
  ): DeleteUserDevicePayload

  """Deletes a single `UserDevice` using a unique key."""
  deleteUserDeviceByToken(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserDeviceByTokenInput!
  ): DeleteUserDevicePayload

  """Upserts a single `Budget`."""
  upsertBudget(
    where: UpsertBudgetWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertBudgetInput!
  ): UpsertBudgetPayload

  """Upserts a single `Category`."""
  upsertCategory(
    where: UpsertCategoryWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertCategoryInput!
  ): UpsertCategoryPayload

  """Upserts a single `OtpVerification`."""
  upsertOtpVerification(
    where: UpsertOtpVerificationWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertOtpVerificationInput!
  ): UpsertOtpVerificationPayload

  """Upserts a single `Report`."""
  upsertReport(
    where: UpsertReportWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertReportInput!
  ): UpsertReportPayload

  """Upserts a single `Transaction`."""
  upsertTransaction(
    where: UpsertTransactionWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertTransactionInput!
  ): UpsertTransactionPayload

  """Upserts a single `User`."""
  upsertUser(
    where: UpsertUserWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertUserInput!
  ): UpsertUserPayload

  """Upserts a single `UserDevice`."""
  upsertUserDevice(
    where: UpsertUserDeviceWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertUserDeviceInput!
  ): UpsertUserDevicePayload
}

"""The output of our create `Budget` mutation."""
type CreateBudgetPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Budget` that was created by this mutation."""
  budget: Budget

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Budget`."""
  user: User

  """Reads a single `Category` that is related to this `Budget`."""
  category: Category

  """An edge for our `Budget`. May be used by Relay 1."""
  budgetEdge(
    """The method to use when ordering `Budget`."""
    orderBy: [BudgetsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BudgetsEdge
}

"""All input for the create `Budget` mutation."""
input CreateBudgetInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Budget` to be created by this mutation."""
  budget: BudgetInput!
}

"""An input for mutations affecting `Budget`"""
input BudgetInput {
  budgetId: String!
  userId: String
  categoryId: String
  amount: Float
  month: Datetime
  alertThreshold: Int
}

"""The output of our create `Category` mutation."""
type CreateCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Category` that was created by this mutation."""
  category: Category

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Category`. May be used by Relay 1."""
  categoryEdge(
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesEdge
}

"""All input for the create `Category` mutation."""
input CreateCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Category` to be created by this mutation."""
  category: CategoryInput!
}

"""An input for mutations affecting `Category`"""
input CategoryInput {
  id: String!
  name: String!
}

"""The output of our create `OtpVerification` mutation."""
type CreateOtpVerificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `OtpVerification` that was created by this mutation."""
  otpVerification: OtpVerification

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `OtpVerification`."""
  user: User

  """An edge for our `OtpVerification`. May be used by Relay 1."""
  otpVerificationEdge(
    """The method to use when ordering `OtpVerification`."""
    orderBy: [OtpVerificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OtpVerificationsEdge
}

"""All input for the create `OtpVerification` mutation."""
input CreateOtpVerificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `OtpVerification` to be created by this mutation."""
  otpVerification: OtpVerificationInput!
}

"""An input for mutations affecting `OtpVerification`"""
input OtpVerificationInput {
  id: String!
  userId: String!
  otp: String!
  expiresAt: Datetime!
  createdAt: Datetime
  email: String
}

"""The output of our create `Report` mutation."""
type CreateReportPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Report` that was created by this mutation."""
  report: Report

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Report`."""
  user: User

  """An edge for our `Report`. May be used by Relay 1."""
  reportEdge(
    """The method to use when ordering `Report`."""
    orderBy: [ReportsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReportsEdge
}

"""All input for the create `Report` mutation."""
input CreateReportInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Report` to be created by this mutation."""
  report: ReportInput!
}

"""An input for mutations affecting `Report`"""
input ReportInput {
  reportId: String!
  userId: String
  createdAt: String
  filePath: String
}

"""The output of our create `Transaction` mutation."""
type CreateTransactionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Transaction` that was created by this mutation."""
  transaction: Transaction

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Transaction`."""
  user: User

  """Reads a single `Category` that is related to this `Transaction`."""
  category: Category

  """An edge for our `Transaction`. May be used by Relay 1."""
  transactionEdge(
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TransactionsEdge
}

"""All input for the create `Transaction` mutation."""
input CreateTransactionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Transaction` to be created by this mutation."""
  transaction: TransactionInput!
}

"""An input for mutations affecting `Transaction`"""
input TransactionInput {
  transactionId: String!
  userId: String
  categoryId: String
  amount: Float!
  date: Datetime
  description: String
  type: Typetransaction
}

"""The output of our create `User` mutation."""
type CreateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was created by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the create `User` mutation."""
input CreateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `User` to be created by this mutation."""
  user: UserInput!
}

"""An input for mutations affecting `User`"""
input UserInput {
  oidcId: String!
  firstName: String
  lastName: String
  gender: UserGender
  email: String
  tel: String
  picture: String
  password: String
  date: Datetime
}

"""The output of our create `UserDevice` mutation."""
type CreateUserDevicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserDevice` that was created by this mutation."""
  userDevice: UserDevice

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserDevice`."""
  user: User

  """An edge for our `UserDevice`. May be used by Relay 1."""
  userDeviceEdge(
    """The method to use when ordering `UserDevice`."""
    orderBy: [UserDevicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserDevicesEdge
}

"""All input for the create `UserDevice` mutation."""
input CreateUserDeviceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserDevice` to be created by this mutation."""
  userDevice: UserDeviceInput!
}

"""An input for mutations affecting `UserDevice`"""
input UserDeviceInput {
  userId: String!
  token: String!
  ua: JSON
}

"""The output of our update `Budget` mutation."""
type UpdateBudgetPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Budget` that was updated by this mutation."""
  budget: Budget

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Budget`."""
  user: User

  """Reads a single `Category` that is related to this `Budget`."""
  category: Category

  """An edge for our `Budget`. May be used by Relay 1."""
  budgetEdge(
    """The method to use when ordering `Budget`."""
    orderBy: [BudgetsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BudgetsEdge
}

"""All input for the `updateBudgetByNodeId` mutation."""
input UpdateBudgetByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Budget` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Budget` being updated.
  """
  patch: BudgetPatch!
}

"""
Represents an update to a `Budget`. Fields that are set will be updated.
"""
input BudgetPatch {
  budgetId: String
  userId: String
  categoryId: String
  amount: Float
  month: Datetime
  alertThreshold: Int
}

"""All input for the `updateBudget` mutation."""
input UpdateBudgetInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Budget` being updated.
  """
  patch: BudgetPatch!
  budgetId: String!
}

"""The output of our update `Category` mutation."""
type UpdateCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Category` that was updated by this mutation."""
  category: Category

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Category`. May be used by Relay 1."""
  categoryEdge(
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesEdge
}

"""All input for the `updateCategoryByNodeId` mutation."""
input UpdateCategoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Category` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Category` being updated.
  """
  patch: CategoryPatch!
}

"""
Represents an update to a `Category`. Fields that are set will be updated.
"""
input CategoryPatch {
  id: String
  name: String
}

"""All input for the `updateCategory` mutation."""
input UpdateCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Category` being updated.
  """
  patch: CategoryPatch!
  id: String!
}

"""The output of our update `OtpVerification` mutation."""
type UpdateOtpVerificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `OtpVerification` that was updated by this mutation."""
  otpVerification: OtpVerification

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `OtpVerification`."""
  user: User

  """An edge for our `OtpVerification`. May be used by Relay 1."""
  otpVerificationEdge(
    """The method to use when ordering `OtpVerification`."""
    orderBy: [OtpVerificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OtpVerificationsEdge
}

"""All input for the `updateOtpVerificationByNodeId` mutation."""
input UpdateOtpVerificationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `OtpVerification` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `OtpVerification` being updated.
  """
  patch: OtpVerificationPatch!
}

"""
Represents an update to a `OtpVerification`. Fields that are set will be updated.
"""
input OtpVerificationPatch {
  id: String
  userId: String
  otp: String
  expiresAt: Datetime
  createdAt: Datetime
  email: String
}

"""All input for the `updateOtpVerification` mutation."""
input UpdateOtpVerificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `OtpVerification` being updated.
  """
  patch: OtpVerificationPatch!
  id: String!
}

"""The output of our update `Report` mutation."""
type UpdateReportPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Report` that was updated by this mutation."""
  report: Report

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Report`."""
  user: User

  """An edge for our `Report`. May be used by Relay 1."""
  reportEdge(
    """The method to use when ordering `Report`."""
    orderBy: [ReportsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReportsEdge
}

"""All input for the `updateReportByNodeId` mutation."""
input UpdateReportByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Report` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Report` being updated.
  """
  patch: ReportPatch!
}

"""
Represents an update to a `Report`. Fields that are set will be updated.
"""
input ReportPatch {
  reportId: String
  userId: String
  createdAt: String
  filePath: String
}

"""All input for the `updateReport` mutation."""
input UpdateReportInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Report` being updated.
  """
  patch: ReportPatch!
  reportId: String!
}

"""The output of our update `Transaction` mutation."""
type UpdateTransactionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Transaction` that was updated by this mutation."""
  transaction: Transaction

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Transaction`."""
  user: User

  """Reads a single `Category` that is related to this `Transaction`."""
  category: Category

  """An edge for our `Transaction`. May be used by Relay 1."""
  transactionEdge(
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TransactionsEdge
}

"""All input for the `updateTransactionByNodeId` mutation."""
input UpdateTransactionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Transaction` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Transaction` being updated.
  """
  patch: TransactionPatch!
}

"""
Represents an update to a `Transaction`. Fields that are set will be updated.
"""
input TransactionPatch {
  transactionId: String
  userId: String
  categoryId: String
  amount: Float
  date: Datetime
  description: String
  type: Typetransaction
}

"""All input for the `updateTransaction` mutation."""
input UpdateTransactionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Transaction` being updated.
  """
  patch: TransactionPatch!
  transactionId: String!
}

"""The output of our update `User` mutation."""
type UpdateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was updated by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `updateUserByNodeId` mutation."""
input UpdateUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
}

"""Represents an update to a `User`. Fields that are set will be updated."""
input UserPatch {
  oidcId: String
  firstName: String
  lastName: String
  gender: UserGender
  email: String
  tel: String
  picture: String
  password: String
  date: Datetime
}

"""All input for the `updateUser` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
  oidcId: String!
}

"""The output of our update `UserDevice` mutation."""
type UpdateUserDevicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserDevice` that was updated by this mutation."""
  userDevice: UserDevice

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserDevice`."""
  user: User

  """An edge for our `UserDevice`. May be used by Relay 1."""
  userDeviceEdge(
    """The method to use when ordering `UserDevice`."""
    orderBy: [UserDevicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserDevicesEdge
}

"""All input for the `updateUserDeviceByNodeId` mutation."""
input UpdateUserDeviceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserDevice` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `UserDevice` being updated.
  """
  patch: UserDevicePatch!
}

"""
Represents an update to a `UserDevice`. Fields that are set will be updated.
"""
input UserDevicePatch {
  userId: String
  token: String
  ua: JSON
}

"""All input for the `updateUserDevice` mutation."""
input UpdateUserDeviceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `UserDevice` being updated.
  """
  patch: UserDevicePatch!
  userId: String!
  token: String!
}

"""All input for the `updateUserDeviceByToken` mutation."""
input UpdateUserDeviceByTokenInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `UserDevice` being updated.
  """
  patch: UserDevicePatch!
  token: String!
}

"""The output of our delete `Budget` mutation."""
type DeleteBudgetPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Budget` that was deleted by this mutation."""
  budget: Budget
  deletedBudgetNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Budget`."""
  user: User

  """Reads a single `Category` that is related to this `Budget`."""
  category: Category

  """An edge for our `Budget`. May be used by Relay 1."""
  budgetEdge(
    """The method to use when ordering `Budget`."""
    orderBy: [BudgetsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BudgetsEdge
}

"""All input for the `deleteBudgetByNodeId` mutation."""
input DeleteBudgetByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Budget` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteBudget` mutation."""
input DeleteBudgetInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  budgetId: String!
}

"""The output of our delete `Category` mutation."""
type DeleteCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Category` that was deleted by this mutation."""
  category: Category
  deletedCategoryNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Category`. May be used by Relay 1."""
  categoryEdge(
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesEdge
}

"""All input for the `deleteCategoryByNodeId` mutation."""
input DeleteCategoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Category` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCategory` mutation."""
input DeleteCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `OtpVerification` mutation."""
type DeleteOtpVerificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `OtpVerification` that was deleted by this mutation."""
  otpVerification: OtpVerification
  deletedOtpVerificationNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `OtpVerification`."""
  user: User

  """An edge for our `OtpVerification`. May be used by Relay 1."""
  otpVerificationEdge(
    """The method to use when ordering `OtpVerification`."""
    orderBy: [OtpVerificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OtpVerificationsEdge
}

"""All input for the `deleteOtpVerificationByNodeId` mutation."""
input DeleteOtpVerificationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `OtpVerification` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteOtpVerification` mutation."""
input DeleteOtpVerificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `Report` mutation."""
type DeleteReportPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Report` that was deleted by this mutation."""
  report: Report
  deletedReportNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Report`."""
  user: User

  """An edge for our `Report`. May be used by Relay 1."""
  reportEdge(
    """The method to use when ordering `Report`."""
    orderBy: [ReportsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReportsEdge
}

"""All input for the `deleteReportByNodeId` mutation."""
input DeleteReportByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Report` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteReport` mutation."""
input DeleteReportInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  reportId: String!
}

"""The output of our delete `Transaction` mutation."""
type DeleteTransactionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Transaction` that was deleted by this mutation."""
  transaction: Transaction
  deletedTransactionNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Transaction`."""
  user: User

  """Reads a single `Category` that is related to this `Transaction`."""
  category: Category

  """An edge for our `Transaction`. May be used by Relay 1."""
  transactionEdge(
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TransactionsEdge
}

"""All input for the `deleteTransactionByNodeId` mutation."""
input DeleteTransactionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Transaction` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTransaction` mutation."""
input DeleteTransactionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  transactionId: String!
}

"""The output of our delete `User` mutation."""
type DeleteUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was deleted by this mutation."""
  user: User
  deletedUserNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `deleteUserByNodeId` mutation."""
input DeleteUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUser` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  oidcId: String!
}

"""The output of our delete `UserDevice` mutation."""
type DeleteUserDevicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserDevice` that was deleted by this mutation."""
  userDevice: UserDevice
  deletedUserDeviceNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserDevice`."""
  user: User

  """An edge for our `UserDevice`. May be used by Relay 1."""
  userDeviceEdge(
    """The method to use when ordering `UserDevice`."""
    orderBy: [UserDevicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserDevicesEdge
}

"""All input for the `deleteUserDeviceByNodeId` mutation."""
input DeleteUserDeviceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserDevice` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUserDevice` mutation."""
input DeleteUserDeviceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  userId: String!
  token: String!
}

"""All input for the `deleteUserDeviceByToken` mutation."""
input DeleteUserDeviceByTokenInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  token: String!
}

"""The output of our upsert `Budget` mutation."""
type UpsertBudgetPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Budget` that was upserted by this mutation."""
  budget: Budget

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Budget`."""
  user: User

  """Reads a single `Category` that is related to this `Budget`."""
  category: Category

  """An edge for our `Budget`. May be used by Relay 1."""
  budgetEdge(
    """The method to use when ordering `Budget`."""
    orderBy: [BudgetsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BudgetsEdge
}

"""Where conditions for the upsert `Budget` mutation."""
input UpsertBudgetWhere {
  budgetId: String
}

"""All input for the upsert `Budget` mutation."""
input UpsertBudgetInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Budget` to be upserted by this mutation."""
  budget: BudgetInput!
}

"""The output of our upsert `Category` mutation."""
type UpsertCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Category` that was upserted by this mutation."""
  category: Category

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Category`. May be used by Relay 1."""
  categoryEdge(
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesEdge
}

"""Where conditions for the upsert `Category` mutation."""
input UpsertCategoryWhere {
  id: String
}

"""All input for the upsert `Category` mutation."""
input UpsertCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Category` to be upserted by this mutation."""
  category: CategoryInput!
}

"""The output of our upsert `OtpVerification` mutation."""
type UpsertOtpVerificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `OtpVerification` that was upserted by this mutation."""
  otpVerification: OtpVerification

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `OtpVerification`."""
  user: User

  """An edge for our `OtpVerification`. May be used by Relay 1."""
  otpVerificationEdge(
    """The method to use when ordering `OtpVerification`."""
    orderBy: [OtpVerificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OtpVerificationsEdge
}

"""Where conditions for the upsert `OtpVerification` mutation."""
input UpsertOtpVerificationWhere {
  id: String
}

"""All input for the upsert `OtpVerification` mutation."""
input UpsertOtpVerificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `OtpVerification` to be upserted by this mutation."""
  otpVerification: OtpVerificationInput!
}

"""The output of our upsert `Report` mutation."""
type UpsertReportPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Report` that was upserted by this mutation."""
  report: Report

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Report`."""
  user: User

  """An edge for our `Report`. May be used by Relay 1."""
  reportEdge(
    """The method to use when ordering `Report`."""
    orderBy: [ReportsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReportsEdge
}

"""Where conditions for the upsert `Report` mutation."""
input UpsertReportWhere {
  reportId: String
}

"""All input for the upsert `Report` mutation."""
input UpsertReportInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Report` to be upserted by this mutation."""
  report: ReportInput!
}

"""The output of our upsert `Transaction` mutation."""
type UpsertTransactionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Transaction` that was upserted by this mutation."""
  transaction: Transaction

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Transaction`."""
  user: User

  """Reads a single `Category` that is related to this `Transaction`."""
  category: Category

  """An edge for our `Transaction`. May be used by Relay 1."""
  transactionEdge(
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TransactionsEdge
}

"""Where conditions for the upsert `Transaction` mutation."""
input UpsertTransactionWhere {
  transactionId: String
}

"""All input for the upsert `Transaction` mutation."""
input UpsertTransactionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Transaction` to be upserted by this mutation."""
  transaction: TransactionInput!
}

"""The output of our upsert `User` mutation."""
type UpsertUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was upserted by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""Where conditions for the upsert `User` mutation."""
input UpsertUserWhere {
  oidcId: String
}

"""All input for the upsert `User` mutation."""
input UpsertUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `User` to be upserted by this mutation."""
  user: UserInput!
}

"""The output of our upsert `UserDevice` mutation."""
type UpsertUserDevicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserDevice` that was upserted by this mutation."""
  userDevice: UserDevice

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserDevice`."""
  user: User

  """An edge for our `UserDevice`. May be used by Relay 1."""
  userDeviceEdge(
    """The method to use when ordering `UserDevice`."""
    orderBy: [UserDevicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserDevicesEdge
}

"""Where conditions for the upsert `UserDevice` mutation."""
input UpsertUserDeviceWhere {
  userId: String
  token: String
}

"""All input for the upsert `UserDevice` mutation."""
input UpsertUserDeviceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserDevice` to be upserted by this mutation."""
  userDevice: UserDeviceInput!
}

"""
The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.

#### Live Queries

Live query fields are differentiated by containing `(live)` at the end of their
description, they are added for each field in the `Query` type. When you
subscribe to a live query field, the selection set will be evaluated and sent to
the client, and then most things\* that would cause the output of the selection
set to change will trigger the selection set to be re-evaluated and the results
to be re-sent to the client.

_(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_

Live queries can be very expensive, so try and keep them small and focussed.

#### Events

Event fields will run their selection set when, and only when, the specified
server-side event occurs. This makes them a lot more efficient than Live
Queries, but it is still recommended that you keep payloads fairly small.
"""
type Subscription {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form. (live)
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. (live)
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`. (live)"""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `Budget`. (live)"""
  budgets(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Budget`."""
    orderBy: [BudgetsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BudgetCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BudgetFilter
  ): BudgetsConnection

  """Reads and enables pagination through a set of `Category`. (live)"""
  categories(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CategoryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CategoryFilter
  ): CategoriesConnection

  """
  Reads and enables pagination through a set of `OtpVerification`. (live)
  """
  otpVerifications(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `OtpVerification`."""
    orderBy: [OtpVerificationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OtpVerificationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OtpVerificationFilter
  ): OtpVerificationsConnection

  """Reads and enables pagination through a set of `Report`. (live)"""
  reports(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Report`."""
    orderBy: [ReportsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReportCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ReportFilter
  ): ReportsConnection

  """Reads and enables pagination through a set of `Transaction`. (live)"""
  transactions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TransactionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TransactionFilter
  ): TransactionsConnection

  """Reads and enables pagination through a set of `User`. (live)"""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): UsersConnection

  """Reads and enables pagination through a set of `UserDevice`. (live)"""
  userDevices(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserDevice`."""
    orderBy: [UserDevicesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserDeviceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserDeviceFilter
  ): UserDevicesConnection

  """ (live)"""
  budget(budgetId: String!): Budget

  """ (live)"""
  category(id: String!): Category

  """ (live)"""
  otpVerification(id: String!): OtpVerification

  """ (live)"""
  report(reportId: String!): Report

  """ (live)"""
  transaction(transactionId: String!): Transaction

  """ (live)"""
  user(oidcId: String!): User

  """ (live)"""
  userDevice(userId: String!, token: String!): UserDevice

  """ (live)"""
  userDeviceByToken(token: String!): UserDevice

  """Reads a single `Budget` using its globally unique `ID`. (live)"""
  budgetByNodeId(
    """The globally unique `ID` to be used in selecting a single `Budget`."""
    nodeId: ID!
  ): Budget

  """Reads a single `Category` using its globally unique `ID`. (live)"""
  categoryByNodeId(
    """The globally unique `ID` to be used in selecting a single `Category`."""
    nodeId: ID!
  ): Category

  """
  Reads a single `OtpVerification` using its globally unique `ID`. (live)
  """
  otpVerificationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `OtpVerification`.
    """
    nodeId: ID!
  ): OtpVerification

  """Reads a single `Report` using its globally unique `ID`. (live)"""
  reportByNodeId(
    """The globally unique `ID` to be used in selecting a single `Report`."""
    nodeId: ID!
  ): Report

  """Reads a single `Transaction` using its globally unique `ID`. (live)"""
  transactionByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Transaction`.
    """
    nodeId: ID!
  ): Transaction

  """Reads a single `User` using its globally unique `ID`. (live)"""
  userByNodeId(
    """The globally unique `ID` to be used in selecting a single `User`."""
    nodeId: ID!
  ): User

  """Reads a single `UserDevice` using its globally unique `ID`. (live)"""
  userDeviceByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `UserDevice`.
    """
    nodeId: ID!
  ): UserDevice
}
